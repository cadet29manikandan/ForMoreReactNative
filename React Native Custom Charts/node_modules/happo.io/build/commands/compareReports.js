"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compareReports;

var _compareSnapshots = _interopRequireDefault(require("../compareSnapshots"));

var _makeRequest = _interopRequireDefault(require("../makeRequest"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function ignore({
  before,
  after,
  apiKey,
  apiSecret,
  endpoint
}) {
  return (0, _makeRequest.default)({
    url: `${endpoint}/api/ignored-diffs`,
    method: 'POST',
    json: true,
    body: {
      snapshot1Id: before.id,
      snapshot2Id: after.id
    }
  }, {
    apiKey,
    apiSecret
  });
}

async function compareReports(sha1, sha2, {
  apiKey,
  apiSecret,
  endpoint,
  project,
  compareThreshold
}, {
  link,
  message,
  author,
  dryRun,
  isAsync,
  notify
}, log = console.log, maxTries = 5) {
  const makeCompareCall = skipStatusPost => (0, _makeRequest.default)({
    url: `${endpoint}/api/reports/${sha1}/compare/${sha2}`,
    method: 'POST',
    json: true,
    body: {
      link,
      message,
      author,
      project,
      skipStatusPost,
      isAsync,
      notify
    }
  }, {
    apiKey,
    apiSecret,
    maxTries
  });

  const firstCompareResult = await makeCompareCall(typeof compareThreshold === 'number' || dryRun);

  if (typeof compareThreshold !== 'number' || isAsync) {
    // We're not using a threshold -- return results right away
    return firstCompareResult;
  }

  const resolved = [];
  log(`Found ${firstCompareResult.diffs.length} diffs to deep-compare using threshold ${compareThreshold}`);

  if (dryRun) {
    log('Running in --dry-run mode -- no destructive commands will be issued');
  }

  const diffsClone = firstCompareResult.diffs.slice(0);
  let batch; // eslint-disable-next-line no-cond-assign

  while ((batch = diffsClone.splice(0, 10)).length > 0) {
    // Batch logs to help avoid running out of file descriptors
    const linesToLog = []; // eslint-disable-next-line no-await-in-loop

    await Promise.all(batch.map(async ([before, after]) => {
      const firstDiffDistance = await (0, _compareSnapshots.default)({
        before,
        after,
        endpoint,
        compareThreshold,
        retries: maxTries,
        apiKey,
        apiSecret
      });

      if (!firstDiffDistance) {
        linesToLog.push(`âœ“ ${after.component} - ${after.variant} - ${after.target} - diff below threshold, auto-ignoring`);

        if (!dryRun) {
          await ignore({
            before,
            after,
            apiKey,
            apiSecret,
            endpoint
          });
        }

        resolved.push([before, after]);
      }
    }));

    if (linesToLog.length) {
      log(linesToLog.join('\n'));
    }
  }

  const totalDiffsCount = firstCompareResult.diffs.length;
  const autoIgnoredDiffsCount = resolved.length;
  log(`${autoIgnoredDiffsCount} out of ${totalDiffsCount} were below threshold and auto-ignored`); // Make second compare call to finalize the deep compare. The second call will
  // cause a status to be posted to the PR (if applicable). Any ignored diffs
  // from the first call will be excluded from the result.

  const secondCompareResult = await makeCompareCall(false);
  log(secondCompareResult.summary);
  return _objectSpread({
    resolved
  }, secondCompareResult);
}