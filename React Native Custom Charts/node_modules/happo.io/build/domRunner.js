"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = domRunner;

var _fs = _interopRequireDefault(require("fs"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _readline = _interopRequireDefault(require("readline"));

var _perf_hooks = require("perf_hooks");

var _JSDOMDomProvider = _interopRequireDefault(require("./JSDOMDomProvider"));

var _Logger = _interopRequireWildcard(require("./Logger"));

var _MultipleErrors = _interopRequireDefault(require("./MultipleErrors"));

var _constructReport = _interopRequireDefault(require("./constructReport"));

var _createDynamicEntryPoint = _interopRequireDefault(require("./createDynamicEntryPoint"));

var _createStaticPackage = _interopRequireDefault(require("./createStaticPackage"));

var _createWebpackBundle = _interopRequireDefault(require("./createWebpackBundle"));

var _loadCSSFile = _interopRequireDefault(require("./loadCSSFile"));

var _makeRequest = _interopRequireDefault(require("./makeRequest"));

var _prepareAssetsPackage = _interopRequireDefault(require("./prepareAssetsPackage"));

var _processSnapsInBundle = _interopRequireDefault(require("./processSnapsInBundle"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  VERBOSE = 'false'
} = process.env;

function logTargetResults({
  name,
  globalCSS,
  snapPayloads,
  project
}) {
  const cssPath = _path.default.join(_os.default.tmpdir(), `happo-verbose-${name}.css`);

  const snippetsPath = _path.default.join(_os.default.tmpdir(), `happo-snippets-${name}.json`);

  _fs.default.writeFileSync(cssPath, JSON.stringify(globalCSS));

  _fs.default.writeFileSync(snippetsPath, JSON.stringify(snapPayloads));

  console.log(`${(0, _Logger.logTag)(project)}Recorded CSS for target "${name}" can be found in ${cssPath}`);
  console.log(`${(0, _Logger.logTag)(project)}Recorded HTML snippets for target "${name}" can be found in ${snippetsPath}`);
}

function waitForAnyKey() {
  _readline.default.emitKeypressEvents(process.stdin);

  process.stdin.setRawMode(true);
  process.stdin.resume();
  return new Promise(resolve => {
    process.stdin.once('keypress', (_, key) => {
      if (key.ctrl && key.name === 'c') {
        process.exit();
      } else {
        process.stdin.setRawMode(false);
        process.stdin.pause();
        resolve();
      }
    });
  });
}

function resolveDomProvider({
  plugins,
  jsdomOptions
}) {
  const pluginWithProvider = plugins.find(({
    DomProvider
  }) => !!DomProvider);

  if (pluginWithProvider) {
    return pluginWithProvider.DomProvider;
  }

  return _JSDOMDomProvider.default.bind(_JSDOMDomProvider.default, jsdomOptions);
}

async function executeTargetWithPrerender({
  name,
  targets,
  css,
  snapPayloads,
  publicFolders,
  cssBlocks,
  apiKey,
  apiSecret,
  endpoint,
  isAsync,
  project
}) {
  if (!snapPayloads.length) {
    console.warn(`${(0, _Logger.logTag)(project)}No examples found for target ${name}, skipping`);
    return [];
  }

  const errors = snapPayloads.filter(p => p.isError);

  if (errors.length === 1) {
    throw errors[0];
  }

  if (errors.length > 1) {
    throw new _MultipleErrors.default(errors);
  }

  const globalCSS = cssBlocks.concat([{
    css
  }]);

  if (VERBOSE === 'true') {
    logTargetResults({
      name,
      globalCSS,
      snapPayloads,
      project
    });
  }

  const assetsPackage = await (0, _prepareAssetsPackage.default)({
    globalCSS,
    snapPayloads,
    publicFolders
  });
  snapPayloads.forEach(item => {
    delete item.assetPaths;
  });
  const result = await targets[name].execute({
    asyncResults: isAsync,
    targetName: name,
    assetsPackage,
    globalCSS,
    snapPayloads,
    apiKey,
    apiSecret,
    endpoint
  });
  return result;
}

async function uploadStaticPackage({
  tmpdir,
  publicFolders,
  endpoint,
  apiKey,
  apiSecret
}) {
  const {
    buffer,
    hash
  } = await (0, _createStaticPackage.default)({
    tmpdir,
    publicFolders
  });
  const assetsRes = await (0, _makeRequest.default)({
    url: `${endpoint}/api/snap-requests/assets/${hash}`,
    method: 'POST',
    json: true,
    formData: {
      payload: {
        options: {
          filename: 'payload.zip',
          contentType: 'application/zip'
        },
        value: buffer
      }
    }
  }, {
    apiKey,
    apiSecret,
    maxTries: 2
  });
  return assetsRes.path;
}

async function generateScreenshots({
  apiKey,
  apiSecret,
  stylesheets,
  endpoint,
  targets,
  publicFolders,
  jsdomOptions,
  plugins,
  prerender,
  tmpdir,
  isAsync,
  project
}, bundleFile, logger) {
  const cssBlocks = await Promise.all(stylesheets.map(async sheet => {
    const {
      source,
      id,
      conditional
    } = typeof sheet === 'string' ? {
      source: sheet
    } : sheet;
    const result = {
      source,
      css: await (0, _loadCSSFile.default)(source)
    };
    if (id) result.id = id;
    if (conditional) result.conditional = conditional;
    return result;
  }));
  plugins.forEach(({
    css
  }) => {
    if (css) {
      cssBlocks.push({
        css
      });
    }
  });
  const targetNames = Object.keys(targets);
  const tl = targetNames.length;
  const DomProvider = resolveDomProvider({
    plugins,
    jsdomOptions
  });
  logger.info(`${(0, _Logger.logTag)(project)}Generating screenshots in ${tl} target${tl > 1 ? 's' : ''}...`);

  try {
    const staticPackage = prerender ? undefined : await uploadStaticPackage({
      tmpdir,
      publicFolders,
      apiKey,
      apiSecret,
      endpoint
    });
    let results;

    if (prerender) {
      const prerenderPromises = [];

      for (const name of targetNames) {
        // These tasks are CPU-bound, and we need to be careful about how much
        // memory we are using at one time, so we want to run them serially.
        // eslint-disable-next-line no-await-in-loop
        const {
          css,
          snapPayloads
        } = await (0, _processSnapsInBundle.default)(bundleFile, {
          targetName: name,
          publicFolders,
          viewport: targets[name].viewport,
          DomProvider
        });
        prerenderPromises.push((async () => {
          const startTime = _perf_hooks.performance.now();

          const result = await executeTargetWithPrerender({
            name,
            css,
            snapPayloads,
            targets,
            publicFolders,
            viewport: targets[name].viewport,
            cssBlocks,
            apiKey,
            apiSecret,
            endpoint,
            logger,
            isAsync,
            project
          });
          logger.start(`  - ${(0, _Logger.logTag)(project)}${name}`, {
            startTime
          });
          logger.success();
          return {
            name,
            result
          };
        })());
      }

      results = await Promise.all(prerenderPromises);
    } else {
      results = await Promise.all(targetNames.map(async name => {
        const startTime = _perf_hooks.performance.now();

        const result = await targets[name].execute({
          asyncResults: isAsync,
          targetName: name,
          staticPackage,
          globalCSS: cssBlocks,
          apiKey,
          apiSecret,
          endpoint
        });
        logger.start(`  - ${(0, _Logger.logTag)(project)}${name}`, {
          startTime
        });
        logger.success();
        return {
          name,
          result
        };
      }));
    }

    if (isAsync) {
      return results;
    }

    return (0, _constructReport.default)(results);
  } catch (e) {
    logger.fail();
    throw e;
  }
}

async function domRunner({
  apiKey,
  apiSecret,
  setupScript,
  customizeWebpackConfig,
  stylesheets,
  include,
  endpoint,
  targets,
  publicFolders,
  rootElementSelector,
  renderWrapperModule,
  prerender,
  type,
  plugins,
  tmpdir,
  jsdomOptions,
  asyncTimeout,
  project
}, {
  only,
  isAsync,
  onReady
}) {
  const boundGenerateScreenshots = generateScreenshots.bind(null, {
    apiKey,
    apiSecret,
    stylesheets,
    endpoint,
    targets,
    publicFolders,
    prerender,
    only,
    isAsync,
    jsdomOptions,
    plugins,
    tmpdir,
    project
  });
  const logger = new _Logger.default();
  logger.start(`${(0, _Logger.logTag)(project)}Searching for happo test files...`);
  let entryFile;

  try {
    const entryPointResult = await (0, _createDynamicEntryPoint.default)({
      setupScript,
      include,
      only,
      type,
      plugins,
      tmpdir,
      rootElementSelector,
      renderWrapperModule,
      asyncTimeout
    });
    entryFile = entryPointResult.entryFile;
    logger.success(`${entryPointResult.numberOfFilesProcessed} found`);
  } catch (e) {
    logger.fail(e);
    throw e;
  }

  const debugIndexHtml = _fs.default.readFileSync(_path.default.resolve(__dirname, 'debug.html'));

  _fs.default.writeFileSync(_path.default.resolve(tmpdir, 'index.html'), debugIndexHtml);

  logger.start(`${(0, _Logger.logTag)(project)}Creating bundle...`);

  if (onReady) {
    let currentBuildPromise;
    let currentLogger;
    let currentWaitPromise; // We're in dev/watch mode

    (0, _createWebpackBundle.default)(entryFile, {
      type,
      customizeWebpackConfig,
      plugins,
      tmpdir
    }, {
      onBuildReady: async bundleFile => {
        if (currentBuildPromise) {
          currentBuildPromise.cancelled = true;
          currentLogger.mute();

          if (currentWaitPromise) {
            currentWaitPromise.cancelled = true;
          } else {
            logger.divider();
            logger.info('Changes detected. Press any key to continue.');
          }

          const waitPromise = waitForAnyKey();
          currentWaitPromise = waitPromise;
          await waitPromise;

          if (waitPromise.cancelled) {
            return;
          }

          logger.divider();
        } else {
          logger.success();
        }

        currentWaitPromise = undefined;
        const mutableLogger = new _Logger.default();
        const buildPromise = boundGenerateScreenshots(bundleFile, mutableLogger);
        currentLogger = mutableLogger;
        currentBuildPromise = buildPromise;

        try {
          const report = await buildPromise;

          if (!buildPromise.cancelled) {
            onReady(report);
          }
        } catch (e) {
          logger.error(e);
        }
      }
    });
    return;
  }

  const bundleFile = await (0, _createWebpackBundle.default)(entryFile, {
    type,
    customizeWebpackConfig,
    plugins,
    tmpdir
  }, {});
  logger.success();
  return boundGenerateScreenshots(bundleFile, logger);
}