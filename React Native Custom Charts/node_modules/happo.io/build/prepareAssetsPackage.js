"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = prepareAssetsPackage;

var _stream = require("stream");

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _archiver = _interopRequireDefault(require("archiver"));

var _findCSSAssetPaths = _interopRequireDefault(require("./findCSSAssetPaths"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// We're setting the creation date to the same for all files so that the zip
// packages created for the same content ends up having the same fingerprint.
const FILE_CREATION_DATE = new Date('Fri Feb 08 2019 13:31:55 GMT+0100 (CET)');

function makePackage({
  paths,
  publicFolders
}) {
  return new Promise((resolve, reject) => {
    const archive = new _archiver.default('zip');
    const stream = new _stream.Writable();
    const data = []; // eslint-disable-next-line no-underscore-dangle

    stream._write = (chunk, enc, done) => {
      data.push(...chunk);
      done();
    };

    stream.on('finish', () => {
      const buffer = Buffer.from(data);
      resolve(buffer);
    });
    archive.pipe(stream);
    Object.keys(paths).forEach(assetPath => {
      const resolvePath = paths[assetPath];

      if (!resolvePath) {
        throw new Error(`Unable to resolve asset path: ${assetPath}`);
      }

      for (const publicFolder of publicFolders) {
        const folder = publicFolder.startsWith('/') ? publicFolder : _path.default.resolve(process.cwd(), publicFolder);

        const fullPath = _path.default.join(folder, assetPath);

        if (_fs.default.existsSync(fullPath)) {
          archive.append(_fs.default.createReadStream(fullPath), {
            name: resolvePath,
            date: FILE_CREATION_DATE
          });
          return;
        } // findCSSAssetPaths will sometimes return absolute paths


        if (assetPath.startsWith(folder) && _fs.default.existsSync(assetPath)) {
          archive.append(_fs.default.createReadStream(assetPath), {
            name: resolvePath,
            date: FILE_CREATION_DATE
          });
          return;
        } // as a last fallback, check if the resolve path exists in the public folder


        const fullResolvePath = _path.default.join(folder, resolvePath);

        if (_fs.default.existsSync(fullResolvePath)) {
          archive.append(_fs.default.createReadStream(fullResolvePath), {
            name: resolvePath,
            date: FILE_CREATION_DATE
          });
          return;
        }
      }
    });
    archive.on('error', reject);
    archive.finalize();
  });
}

function prepareAssetsPackage({
  globalCSS,
  snapPayloads,
  publicFolders
}) {
  const paths = {};
  globalCSS.forEach(({
    css,
    source
  }) => {
    (0, _findCSSAssetPaths.default)({
      css,
      source
    }).forEach(({
      assetPath,
      resolvePath
    }) => {
      paths[assetPath] = resolvePath;
    });
  });
  snapPayloads.forEach(({
    assetPaths
  }) => {
    assetPaths.forEach(assetPath => {
      paths[assetPath] = assetPath;
    });
  });
  return makePackage({
    paths,
    publicFolders
  });
}