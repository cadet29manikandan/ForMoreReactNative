import { Blueprint } from 'optimal';
import { Arguments, Options as ArgOptions } from 'yargs-parser';
import { AbstractConstructor, Path, FilePath, PortablePath } from '@boost/common';
import { Event } from '@boost/event';
import { Debugger } from '@boost/debug';
import { Logger } from '@boost/log';
import { Translator } from '@boost/translate';
import Console from './Console';
import Emitter from './Emitter';
import Reporter from './Reporter';
import { PackageConfig, PluginType, PluginSetting, WorkspaceMetadata, WorkspacePackageConfig, WorkspaceOptions, OutputLevel } from './types';
export interface ToolOptions {
    appName: string;
    appPath: string;
    argOptions?: ArgOptions;
    configBlueprint?: Blueprint<any>;
    configName?: string;
    footer?: string;
    header?: string;
    root?: string;
    scoped?: boolean;
    settingsBlueprint?: Blueprint<any>;
    workspaceRoot?: string;
}
export interface ToolConfig {
    debug: boolean;
    extends: string[];
    locale: string;
    output: OutputLevel;
    reporters: PluginSetting<Reporter>;
    settings: {
        [key: string]: any;
    };
    silent: boolean;
    theme: string;
}
export interface ToolPluginRegistry {
    reporter: Reporter;
}
export default class Tool<PluginRegistry extends ToolPluginRegistry, Config extends ToolConfig = ToolConfig> extends Emitter {
    appPath: Path;
    args?: Arguments;
    argv: string[];
    config: Config;
    console: Console;
    debug: Debugger;
    log: Logger;
    msg: Translator;
    onExit: Event<[number], string>;
    onInit: Event<[], string>;
    onLoadPlugin: Event<[PluginRegistry[keyof PluginRegistry]], Extract<keyof PluginRegistry, string>>;
    options: Required<ToolOptions>;
    package: PackageConfig;
    rootPath: Path;
    private configLoader;
    private initialized;
    private plugins;
    private pluginTypes;
    constructor(options: ToolOptions, argv?: string[]);
    /**
     * Add a plugin for a specific contract type and bootstrap with the tool.
     */
    addPlugin<K extends keyof PluginRegistry>(typeName: K, plugin: PluginRegistry[K]): this;
    /**
     * Create a workspace metadata object composed of absolute file paths.
     */
    createWorkspaceMetadata(jsonPath: PortablePath): WorkspaceMetadata;
    /**
     * Force exit the application.
     */
    exit(message?: string | Error | null, code?: number): this;
    /**
     * Return a plugin by name and type.
     */
    getPlugin<K extends keyof PluginRegistry>(typeName: K, name: string): PluginRegistry[K];
    /**
     * Return all plugins by type.
     */
    getPlugins<K extends keyof PluginRegistry>(typeName: K): PluginRegistry[K][];
    /**
     * Return a registered plugin type by name.
     */
    getRegisteredPlugin<K extends keyof PluginRegistry>(typeName: K): PluginType<PluginRegistry[K]>;
    /**
     * Return the registered plugin types.
     */
    getRegisteredPlugins(): { [K in keyof PluginRegistry]?: PluginType<PluginRegistry[K]> | undefined; };
    /**
     * Return all `package.json`s across all workspaces and their packages.
     * Once loaded, append workspace path metadata.
     */
    getWorkspacePackages<CustomConfig extends object = {}>(options?: WorkspaceOptions): (WorkspacePackageConfig & CustomConfig)[];
    /**
     * Return a list of absolute package folder paths, across all workspaces,
     * for the defined root.
     */
    getWorkspacePackagePaths(options?: WorkspaceOptions): FilePath[];
    /**
     * Return a list of workspace folder paths, with wildstar glob in tact,
     * for the defined root.
     */
    getWorkspacePaths(options?: WorkspaceOptions): FilePath[];
    /**
     * Initialize the tool by loading config and plugins.
     */
    initialize(): this;
    /**
     * Return true if running in a CI environment.
     */
    isCI(): boolean;
    /**
     * Return true if a plugin by type has been enabled in the configuration file
     * by property name of the same type.  The following variants are supported:
     *
     * - As a string using the plugins name: "foo"
     * - As an object with a property by plugin type: { plugin: "foo" }
     * - As an instance of the plugin class: new Plugin()
     */
    isPluginEnabled<K extends keyof PluginRegistry>(typeName: K, name: string): boolean;
    /**
     * Load all `package.json`s across all workspaces and their packages.
     * Once loaded, append workspace path metadata.
     *
     * @deprecated
     */
    loadWorkspacePackages<CustomConfig extends object = {}>(options?: WorkspaceOptions): (WorkspacePackageConfig & CustomConfig)[];
    /**
     * Log a live message to the console to display while a process is running.
     *
     * @deprecated
     */
    logLive(message: string, ...args: any[]): this;
    /**
     * Log an error to the console to display on failure.
     *
     * @deprecated
     */
    logError(message: string, ...args: any[]): this;
    /**
     * Register a custom type of plugin, with a defined contract that all instances should extend.
     * The type name should be in singular form, as plural variants are generated automatically.
     */
    registerPlugin<K extends keyof PluginRegistry>(typeName: K, contract: AbstractConstructor<PluginRegistry[K]>, options?: Partial<Pick<PluginType<PluginRegistry[K]>, 'afterBootstrap' | 'beforeBootstrap' | 'scopes'>>): this;
    /**
     * Load the package.json and local configuration files.
     *
     * Must be called first in the lifecycle.
     */
    protected loadConfig(): this;
    /**
     * Register plugins from the loaded configuration.
     *
     * Must be called after config has been loaded.
     */
    protected loadPlugins(): this;
    /**
     * Register reporters from the loaded configuration.
     *
     * Must be called after config has been loaded.
     */
    protected loadReporters(): this;
}
//# sourceMappingURL=Tool.d.ts.map