import Console from './Console';
import Output, { StringRenderer } from './Output';
import ProgressOutput, { ProgressRenderer } from './outputs/ProgressOutput';
import Plugin from './Plugin';
import Routine from './Routine';
import Task from './Task';
import { ColorType, ColorPalette, OutputLevel } from './types';
export declare const SLOW_THRESHOLD = 10000;
export default abstract class Reporter<Options extends object = {}> extends Plugin<Options> {
    static BUFFER: number;
    static OUTPUT_COMPACT: number;
    static OUTPUT_NORMAL: number;
    static OUTPUT_VERBOSE: number;
    console: Console;
    startTime: number;
    stopTime: number;
    /**
     * Register console listeners.
     */
    bootstrap(): void;
    /**
     * Calculate the current number of tasks that have completed.
     */
    calculateTaskCompletion(tasks: Task<any>[]): number;
    /**
     * Create a new output to be rendered with the defined renderer function.
     * Concurrent outputs will be rendered in parallel with other concurrent
     * outputs and the top of the queue output.
     */
    createConcurrentOutput(renderer: StringRenderer): Output;
    /**
     * Create a new output to be rendered with the defined renderer function.
     */
    createOutput(renderer: StringRenderer): Output;
    /**
     * Create a new output to continuously render a progress bar.
     */
    createProgressOutput(renderer: ProgressRenderer): ProgressOutput;
    /**
     * Display an error and it's stack.
     */
    displayError(error: Error): void;
    /**
     * Return specific colors based on chosen theme.
     */
    getColorPalette(): ColorPalette;
    /**
     * Return a specific color for each task status.
     */
    getColorType(task: Task<any>): ColorType;
    /**
     * Calculate the elapsed time and highlight as red if over the threshold.
     */
    getElapsedTime(start: number, stop?: number, highlight?: boolean): string;
    /**
     * Return the output level: 1 (compact), 2 (normal), 3 (verbose).
     */
    getOutputLevel(): OutputLevel;
    /**
     * Return the root parent (depth of 0) in the current routine tree.
     */
    getRootParent(routine: Routine<any, any>): Routine<any, any>;
    /**
     * Set start time.
     */
    handleBaseStart: () => void;
    /**
     * Set stop time and render.
     */
    handleBaseStop: () => void;
    /**
     * Return true if the user's terminal supports color.
     */
    hasColorSupport(level?: number): boolean;
    /**
     * Hide the console cursor.
     */
    hideCursor(): this;
    /**
     * Create an indentation based on the defined length.
     */
    indent(length?: number): string;
    /**
     * Return true if the final render.
     */
    isFinalRender(): boolean;
    /**
     * Return true if the there should be no output.
     */
    isSilent(): boolean;
    /**
     * Reset the cursor back to the bottom of the console.
     */
    resetCursor(): this;
    /**
     * Show the console cursor.
     */
    showCursor(): this;
    /**
     * Return size information about the terminal window.
     */
    size(): {
        columns: number;
        rows: number;
    };
    /**
     * Sort all tasks by start time and filter to remove pending tasks.
     */
    sortTasksByStartTime<T extends Task<any>>(tasks: T[]): T[];
    /**
     * Strip ANSI escape characters from a string.
     */
    strip(message: string): string;
    /**
     * Create a chalk formatted string with accessible colors and modifiers applied.
     */
    style(message: string, type?: ColorType, modifiers?: ('reset' | 'bold' | 'dim' | 'italic' | 'underline' | 'inverse' | 'hidden')[]): string;
    /**
     * Truncate a string that contains ANSI escape characters to a specific column width.
     */
    truncate(message: string, columns?: number, options?: {
        position?: 'start' | 'middle' | 'end';
    }): string;
    /**
     * Wrap a string that contains ANSI escape characters to a specific column width.
     */
    wrap(message: string, columns?: number, options?: {
        hard?: boolean;
        trim?: boolean;
        wordWrap?: boolean;
    }): string;
}
export declare function testOnlyResetRestoreCursor(): void;
//# sourceMappingURL=Reporter.d.ts.map