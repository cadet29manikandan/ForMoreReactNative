import { Event, BailEvent } from '@boost/event';
import Emitter from './Emitter';
import Context from './Context';
import { Status } from './types';
export declare type TaskAction<Ctx extends Context> = (context: Ctx, value: any, task: Task<Ctx>) => unknown | Promise<unknown>;
export interface TaskMetadata {
    depth: number;
    index: number;
    startTime: number;
    stopTime: number;
}
export default class Task<Ctx extends Context> extends Emitter {
    action: TaskAction<Ctx>;
    context: Ctx;
    title: string;
    metadata: TaskMetadata;
    onFail: Event<[Error | null]>;
    onPass: Event<[unknown]>;
    onRun: BailEvent<[unknown]>;
    onSkip: Event<[unknown]>;
    output: unknown;
    parent: Task<Ctx> | null;
    status: Status;
    statusText: string;
    constructor(title: string, action: TaskAction<Ctx>);
    /**
     * Return true if the task failed when executing.
     */
    hasFailed(): boolean;
    /**
     * Return true if the task executed successfully.
     */
    hasPassed(): boolean;
    /**
     * Return true if the task has been completed in any form.
     */
    isComplete(): boolean;
    /**
     * Return true if the task has not been executed yet.
     */
    isPending(): boolean;
    /**
     * Return true if the task is currently running.
     */
    isRunning(): boolean;
    /**
     * Return true if the task was or will be skipped.
     */
    isSkipped(): boolean;
    /**
     * Run the current task by executing it and performing any before and after processes.
     */
    run(context: Ctx, value: any): Promise<any>;
    /**
     * Set the context to be passed around.
     */
    setContext(context: Ctx): this;
    /**
     * Mark a task as skipped if the condition is true.
     */
    skip(condition?: boolean): this;
}
//# sourceMappingURL=Task.d.ts.map