import { Arguments } from 'yargs-parser';
import { Path, FilePath, PortablePath } from '@boost/common';
import { Debugger } from '@boost/debug';
import Tool, { ToolConfig } from './Tool';
import { PackageConfig } from './types';
export interface ConfigLike {
    [key: string]: unknown;
    extends?: ToolConfig['extends'];
}
export declare type ConfigPathOrObject = Path | ConfigLike;
export interface ParseOptions {
    errorOnFunction?: boolean;
}
export default class ConfigLoader {
    debug: Debugger;
    package: PackageConfig;
    parsedFiles: Set<string>;
    tool: Tool<any>;
    workspaceRoot: string;
    constructor(tool: Tool<any>);
    /**
     * Find the config using the --config file path option.
     */
    findConfigFromArg(filePath?: FilePath): ConfigPathOrObject | null;
    /**
     * Find the config in the package.json block under the application name.
     */
    findConfigInPackageJSON(pkg: PackageConfig): ConfigPathOrObject | null;
    /**
     * Find the config using local files commonly located in a configs/ folder.
     */
    findConfigInLocalFiles(root: PortablePath): ConfigPathOrObject | null;
    /**
     * Find the config within the root when in a workspace.
     */
    findConfigInWorkspaceRoot(root: PortablePath): ConfigPathOrObject | null;
    /**
     * Return the config name used for file names and the package.json property.
     */
    getConfigName(): string;
    /**
     * Inherit configuration settings from defined CLI options.
     */
    inheritFromArgs<T>(config: T, args: Arguments): T;
    /**
     * Load a local configuration file relative to the current working directory,
     * or from within a package.json property of the same appName.
     *
     * Support both JSON and JS file formats by globbing the config directory.
     */
    loadConfig<T>(args: Arguments): T;
    /**
     * Load the "package.json" from the current working directory,
     * as we require the dev tool to be ran from the project root.
     */
    loadPackageJSON(): PackageConfig;
    /**
     * If an `extends` option exists, recursively merge the current configuration
     * with the preset configurations defined within `extends`,
     * and return the new configuration object.
     */
    parseAndExtend(fileOrConfig: ConfigPathOrObject): ConfigLike;
    /**
     * Parse a configuration file at the defined file system path.
     * If the file ends in "json" or "json5", parse it with JSON5.
     * If the file ends in "js", import the file and use the default object.
     * Otherwise throw an error.
     */
    parseFile<T>(basePath: PortablePath, args?: any[], options?: ParseOptions): T;
    /**
     * Resolve file system paths for the `extends` configuration value
     * using the following guidelines:
     *
     *  - Absolute paths should be normalized and used as is.
     *  - Relative paths should be resolved relative to the CWD.
     *  - Strings that match a node module name should resolve to a config file relative to the CWD.
     *  - Strings that start with "<plugin>:" should adhere to the previous rule.
     */
    resolveExtendPaths(extendPaths: string[], baseDir?: string): Path[];
    /**
     * Resolve a Node/NPM module path to an app config file.
     */
    resolveModuleConfigPath(configName: string, moduleName: string, preset?: boolean, ext?: string): FilePath;
}
//# sourceMappingURL=ConfigLoader.d.ts.map