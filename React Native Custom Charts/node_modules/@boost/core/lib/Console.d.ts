/// <reference types="node" />
import { Debugger } from '@boost/debug';
import { Event } from '@boost/event';
import Emitter from './Emitter';
import Task from './Task';
import Tool from './Tool';
import Output from './Output';
import Routine from './Routine';
export declare const FPS_RATE = 125;
export declare const BOUND_WRITERS: {
    stderr: {
        (buffer: string | Uint8Array, cb?: ((err?: Error | undefined) => void) | undefined): boolean;
        (str: string | Uint8Array, encoding?: string | undefined, cb?: ((err?: Error | undefined) => void) | undefined): boolean;
    };
    stdout: {
        (buffer: string | Uint8Array, cb?: ((err?: Error | undefined) => void) | undefined): boolean;
        (str: string | Uint8Array, encoding?: string | undefined, cb?: ((err?: Error | undefined) => void) | undefined): boolean;
    };
};
export declare const WRAPPED_STREAMS: {
    stderr: boolean;
    stdout: boolean;
};
export declare type StreamType = 'stderr' | 'stdout';
export interface ConsoleState {
    disabled: boolean;
    final: boolean;
    started: boolean;
    stopped: boolean;
}
export default class Console extends Emitter {
    bufferedStreams: (() => void)[];
    debug: Debugger;
    errorLogs: string[];
    logs: string[];
    onError: Event<[Error]>;
    onRoutine: Event<[Routine<any, any>, unknown, boolean]>;
    onRoutines: Event<[Routine<any, any>[], unknown, boolean]>;
    onStart: Event<unknown[]>;
    onStop: Event<[Error | null]>;
    onTask: Event<[Task<any>, unknown, boolean]>;
    onTasks: Event<[Task<any>[], unknown, boolean]>;
    outputQueue: Output[];
    tool: Tool<any>;
    protected renderTimer: NodeJS.Timer | null;
    protected state: ConsoleState;
    private writers;
    constructor(tool: Tool<any>, /* test only */ testWriters?: typeof BOUND_WRITERS);
    /**
     * Disable the render loop entirely.
     */
    disable(): this;
    /**
     * Display a footer after all output.
     */
    displayFooter(): void;
    /**
     * Display a header before all output.
     */
    displayHeader(): void;
    /**
     * Enable the render loop.
     */
    enable(): this;
    /**
     * Write a message to `stderr` with optional trailing newline(s).
     */
    err(message: string, nl?: number): this;
    /**
     * Flush buffered stream output.
     */
    flushBufferedStreams(): this;
    /**
     * Flush the top output block in the queue.
     */
    flushOutputQueue(): this;
    /**
     * Handle uncaught exceptions and unhandled rejections that bubble up.
     */
    handleFailure: (error: Error) => void;
    /**
     * Handle SIGINT and SIGTERM interruptions.
     */
    handleSignal: (signal: NodeJS.Signals) => void;
    /**
     * Hide the console cursor.
     */
    hideCursor(): this;
    /**
     * Return true if the render loop has been disabled.
     */
    isDisabled(): boolean;
    /**
     * Return true if the output queue is empty.
     */
    isEmptyQueue(): boolean;
    /**
     * Return true if the final render.
     */
    isFinalRender(): boolean;
    /**
     * Return true if the there should be no output.
     */
    isSilent(): boolean;
    /**
     * Return true if the defined stream has been wrapped by the console layer.
     */
    isStreamWrapped(type: StreamType): boolean;
    /**
     * Log a message to display on success during the final render.
     */
    log(message: string): this;
    /**
     * Log a live message to display during the rendering process.
     */
    logLive(message: string): this;
    /**
     * Log an error message to display on failure during the final render.
     */
    logError(message: string): this;
    /**
     * Write a message to `stdout` with optional trailing newline(s).
     */
    out(message: string, nl?: number): this;
    /**
     * Enqueue a block of output to be rendered.
     */
    render(output: Output): this;
    /**
     * Handle the final rendering of all output before stopping.
     */
    renderFinalOutput(error: Error | null): void;
    /**
     * Reset the cursor back to the bottom of the console.
     */
    resetCursor(): this;
    /**
     * Show the console cursor.
     */
    showCursor(): this;
    /**
     * Start the console by wrapping streams and buffering output.
     */
    start(args?: any[]): this;
    /**
     * Automatically render the console in a timeout loop at 8 FPS.
     */
    startRenderLoop(): void;
    /**
     * Stop the console rendering process.
     */
    stop(error?: Error | null): void;
    /**
     * Stop the background render loop.
     */
    stopRenderLoop(): void;
    /**
     * Unwrap the native console and reset it back to normal.
     */
    unwrapStreams(): void;
    /**
     * Wrap the `stdout` and `stderr` streams and buffer the output as
     * to not collide with our render loop.
     */
    wrapStreams(): void;
}
//# sourceMappingURL=Console.d.ts.map