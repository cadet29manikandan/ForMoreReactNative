import { Debugger } from '@boost/debug';
import Context from './Context';
import Routine from './Routine';
import Task from './Task';
import Tool from './Tool';
export declare type ExecuteHandler<Ctx extends Context> = (task: Task<Ctx>, value?: any) => Promise<any>;
export interface AggregatedResponse<T> {
    errors: Error[];
    results: T[];
}
export default abstract class Executor<Ctx extends Context, Options extends object = {}> {
    context: Ctx;
    debug: Debugger;
    options: Options;
    parallel: boolean;
    tool: Tool<any>;
    constructor(tool: Tool<any>, context: Ctx, options?: Options);
    /**
     * Aggregate and partition errors and results into separate collections.
     */
    aggregateResponse<T>(responses: T[]): AggregatedResponse<T>;
    /**
     * Execute a routine with the provided value.
     */
    executeRoutine: <T>(routine: Routine<Ctx, any, {}>, value?: T | undefined) => Promise<any>;
    /**
     * Execute a task with the provided value.
     */
    executeTask: <T>(task: Task<Ctx>, value?: T | undefined) => Promise<any>;
    /**
     * Run all routines with the defined executor.
     */
    runRoutines<T>(routines: Routine<Ctx, any>[], value?: T): Promise<any>;
    /**
     * Run all tasks with the defined executor.
     */
    runTasks<T>(tasks: Task<Ctx>[], value?: T): Promise<any>;
    /**
     * Method to execute tasks. Must be defined in sub-classes.
     */
    abstract run<T>(handler: ExecuteHandler<Ctx>, tasks: Task<Ctx>[], value?: T): Promise<any>;
}
//# sourceMappingURL=Executor.d.ts.map