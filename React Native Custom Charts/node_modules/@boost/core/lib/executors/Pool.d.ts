/// <reference types="node" />
import Context from '../Context';
import Executor, { AggregatedResponse, ExecuteHandler } from '../Executor';
import Task from '../Task';
import Tool from '../Tool';
export interface PoolExecutorOptions {
    concurrency?: number;
    fifo?: boolean;
    timeout?: number;
}
export default class PoolExecutor<Ctx extends Context> extends Executor<Ctx, PoolExecutorOptions> {
    handler: ExecuteHandler<Ctx> | null;
    parallel: boolean;
    queue: Task<Ctx>[];
    resolver: ((response: AggregatedResponse<any>) => void) | null;
    results: any[];
    running: Task<Ctx>[];
    timeoutTimer?: NodeJS.Timer;
    constructor(tool: Tool<any>, context: Ctx, options?: PoolExecutorOptions);
    /**
     * Execute tasks using a pool with a max concurrency.
     */
    run<T, R = any>(handler: ExecuteHandler<Ctx>, tasks: Task<Ctx>[], value?: T): Promise<AggregatedResponse<R>>;
    /**
     * Resolve the execution with the current results.
     */
    resolve(): void;
    /**
     * Run a task from the queue, and start the next task one it passes or fails.
     */
    runItem<T>(value?: T): Promise<void>;
    /**
     * Run the next task if there are tasks available in the queue, and the max concurrency isn't met.
     * Otherwise, resolve and exit the current pool.
     */
    nextItem<T>(value?: T): void;
}
//# sourceMappingURL=Pool.d.ts.map