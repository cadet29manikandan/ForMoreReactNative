"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const event_1 = require("@boost/event");
const Emitter_1 = __importDefault(require("./Emitter"));
const constants_1 = require("./constants");
class Task extends Emitter_1.default {
    constructor(title, action) {
        super();
        this.metadata = {
            depth: 0,
            index: 0,
            startTime: 0,
            stopTime: 0,
        };
        this.output = '';
        this.parent = null;
        this.status = constants_1.STATUS_PENDING;
        this.statusText = '';
        if (!title || typeof title !== 'string') {
            throw new Error('Tasks require a title.');
        }
        if (action !== null && typeof action !== 'function') {
            throw new Error('Tasks require an executable function.');
        }
        this.action = action;
        this.status = constants_1.STATUS_PENDING;
        this.title = title;
        this.onFail = new event_1.Event('fail');
        this.onPass = new event_1.Event('pass');
        this.onRun = new event_1.BailEvent('run');
        this.onSkip = new event_1.Event('skip');
    }
    /**
     * Return true if the task failed when executing.
     */
    hasFailed() {
        return this.status === constants_1.STATUS_FAILED;
    }
    /**
     * Return true if the task executed successfully.
     */
    hasPassed() {
        return this.status === constants_1.STATUS_PASSED;
    }
    /**
     * Return true if the task has been completed in any form.
     */
    isComplete() {
        return this.hasPassed() || this.hasFailed() || this.isSkipped();
    }
    /**
     * Return true if the task has not been executed yet.
     */
    isPending() {
        return this.status === constants_1.STATUS_PENDING;
    }
    /**
     * Return true if the task is currently running.
     */
    isRunning() {
        return this.status === constants_1.STATUS_RUNNING;
    }
    /**
     * Return true if the task was or will be skipped.
     */
    isSkipped() {
        return this.status === constants_1.STATUS_SKIPPED;
    }
    /**
     * Run the current task by executing it and performing any before and after processes.
     */
    run(context, value) {
        return __awaiter(this, void 0, void 0, function* () {
            this.setContext(context);
            this.emit('run', [value]);
            const skip = this.onRun.emit([value]);
            if (skip || this.isSkipped()) {
                this.status = constants_1.STATUS_SKIPPED;
                this.emit('skip', [value]);
                this.onSkip.emit([value]);
                return Promise.resolve(value);
            }
            this.status = constants_1.STATUS_RUNNING;
            this.metadata.startTime = Date.now();
            try {
                this.output = yield this.action(context, value, this);
                this.status = constants_1.STATUS_PASSED;
                this.metadata.stopTime = Date.now();
                this.emit('pass', [this.output]);
                this.onPass.emit([this.output]);
            }
            catch (error) {
                this.status = constants_1.STATUS_FAILED;
                this.metadata.stopTime = Date.now();
                this.emit('fail', [error]);
                this.onFail.emit([error]);
                throw error;
            }
            this.statusText = '';
            return this.output;
        });
    }
    /**
     * Set the context to be passed around.
     */
    setContext(context) {
        this.context = context;
        return this;
    }
    /**
     * Mark a task as skipped if the condition is true.
     */
    skip(condition = true) {
        if (condition) {
            this.status = constants_1.STATUS_SKIPPED;
        }
        return this;
    }
}
exports.default = Task;
