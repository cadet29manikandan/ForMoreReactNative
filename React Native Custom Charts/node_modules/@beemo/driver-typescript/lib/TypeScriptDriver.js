"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const rimraf_1 = __importDefault(require("rimraf"));
const event_1 = require("@boost/event");
const core_1 = require("@beemo/core");
function join(...parts) {
    return new core_1.Path(...parts).path();
}
// Success: Writes nothing to stdout or stderr
// Failure: Writes to stdout on syntax and type error
class TypeScriptDriver extends core_1.Driver {
    constructor() {
        super(...arguments);
        this.onCreateProjectConfigFile = new event_1.Event('create-project-config-file');
        /**
         * Automatically clean the target folder if `outDir` and `--clean` is used.
         */
        this.handleCleanTarget = ({ args }) => {
            const outDir = args.outDir || (this.config.compilerOptions && this.config.compilerOptions.outDir);
            if (args.clean && outDir) {
                rimraf_1.default.sync(core_1.Path.resolve(outDir).path());
            }
            return Promise.resolve();
        };
        /**
         * Define references and compiler options when `--reference-workspaces` option is passed.
         */
        this.handlePrepareConfigs = (context, configPath, config) => {
            const { args, workspaceRoot } = context;
            if (!args.referenceWorkspaces) {
                return;
            }
            // Add to context so that it can be automatically cleaned up
            context.addConfigPath('typescript', this.prepareProjectRefsRootConfigs(workspaceRoot, configPath, config));
        };
        /**
         * Automatically create `tsconfig.json` files in each workspace package with project
         * references linked correctly. Requires the `--reference-workspaces` option.
         */
        this.handleProjectReferences = (context) => {
            const { args, workspaceRoot } = context;
            if (!args.referenceWorkspaces) {
                return Promise.resolve();
            }
            else if (!args.build && !args.b) {
                throw new Error(this.tool.msg('errors:workspacesProjectRefsBuildRequired'));
            }
            else if (args.workspaces) {
                throw new Error(this.tool.msg('errors:workspacesProjectRefsMixed'));
            }
            return this.createProjectRefConfigsInWorkspaces(context, workspaceRoot);
        };
    }
    blueprint(preds) {
        const { bool, string } = preds;
        return Object.assign(Object.assign({}, super.blueprint(preds)), { buildFolder: string('lib'), declarationOnly: bool(), globalTypes: bool(true), localTypes: bool(true), srcFolder: string('src'), testsFolder: string('tests'), typesFolder: string('types') });
    }
    bootstrap() {
        this.setMetadata({
            bin: 'tsc',
            configName: 'tsconfig.json',
            configOption: '',
            description: this.tool.msg('app:typescriptDescription'),
            helpOption: '--help --all',
            title: 'TypeScript',
            watchOptions: ['-w', '--watch'],
            workspaceStrategy: 'copy',
        });
        this.setCommandOptions({
            clean: {
                boolean: true,
                default: false,
                description: this.tool.msg('app:typescriptCleanOption'),
            },
        });
        this.onCreateConfigFile.listen(this.handlePrepareConfigs);
        this.onBeforeExecute.listen(this.handleCleanTarget);
        this.onBeforeExecute.listen(this.handleProjectReferences);
    }
    /**
     * Create a `tsconfig.json` in each workspace package. Automatically link packages
     * together using project references. Attempt to handle source and test folders.
     */
    createProjectRefConfigsInWorkspaces(context, workspaceRoot) {
        return __awaiter(this, void 0, void 0, function* () {
            const { buildFolder, declarationOnly, srcFolder, testsFolder, typesFolder, globalTypes, localTypes, } = this.options;
            const optionsConfigPath = workspaceRoot.append('tsconfig.options.json');
            const globalTypesPath = workspaceRoot.append(typesFolder, '**/*');
            const namesToPaths = {};
            const workspacePackages = this.tool.getWorkspacePackages({
                root: workspaceRoot,
            });
            // Helper to write a file and return a promise
            const writeFile = (filePath, config, isTests) => {
                const configPath = filePath.append('tsconfig.json');
                this.onCreateProjectConfigFile.emit([context, configPath, config, isTests]);
                return new Promise((resolve, reject) => {
                    fs_1.default.writeFile(configPath.path(), this.formatConfig(config), (error) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve();
                        }
                    });
                });
            };
            // Map package name to absolute paths
            workspacePackages.forEach((wsPkg) => {
                namesToPaths[wsPkg.name] = wsPkg.workspace.packagePath;
            });
            // Create a config file in each package
            return Promise.all(workspacePackages.map(
            // eslint-disable-next-line complexity
            ({ dependencies = {}, devDependencies = {}, peerDependencies = {}, tsconfig = {}, workspace, }) => {
                const pkgPath = new core_1.Path(workspace.packagePath);
                const srcPath = pkgPath.append(srcFolder);
                const testsPath = pkgPath.append(testsFolder);
                const references = [];
                const promises = [];
                // Extract and determine references
                Object.keys(Object.assign(Object.assign(Object.assign({}, dependencies), devDependencies), peerDependencies)).forEach((depName) => {
                    if (namesToPaths[depName]) {
                        references.push({
                            path: pkgPath.relativeTo(namesToPaths[depName]).path(),
                        });
                    }
                });
                // Build package config
                if (srcFolder && srcPath.exists()) {
                    const packageConfig = {
                        compilerOptions: Object.assign(Object.assign({}, tsconfig.compilerOptions), { declarationDir: buildFolder, outDir: buildFolder, rootDir: srcFolder }),
                        exclude: [buildFolder],
                        extends: pkgPath.relativeTo(optionsConfigPath).path(),
                        include: [join(srcFolder, '**/*')],
                        references,
                    };
                    if (declarationOnly) {
                        packageConfig.compilerOptions.emitDeclarationOnly = true;
                    }
                    if (localTypes) {
                        packageConfig.include.push(join(typesFolder, '**/*'));
                    }
                    if (globalTypes) {
                        packageConfig.include.push(pkgPath.relativeTo(globalTypesPath).path());
                    }
                    if (testsFolder) {
                        packageConfig.exclude.push(testsFolder);
                    }
                    if (Array.isArray(tsconfig.exclude)) {
                        packageConfig.exclude.push(...tsconfig.exclude);
                    }
                    promises.push(writeFile(pkgPath, packageConfig, false));
                }
                // Build tests specific package config
                if (testsFolder && testsPath.exists()) {
                    const testConfig = {
                        compilerOptions: {
                            composite: false,
                            emitDeclarationOnly: false,
                            noEmit: true,
                            rootDir: '.',
                        },
                        extends: testsPath.relativeTo(optionsConfigPath).path(),
                        include: ['**/*'],
                        references: [{ path: '..' }],
                    };
                    if (localTypes) {
                        testConfig.include.push(join('..', typesFolder, '**/*'));
                    }
                    if (globalTypes) {
                        testConfig.include.push(testsPath.relativeTo(globalTypesPath).path());
                    }
                    promises.push(writeFile(testsPath, testConfig, true));
                }
                return Promise.all(promises);
            }));
        });
    }
    /**
     * Extract compiler options from the root config into a separate config purely for
     * extending options. Update the root config with references to all workspaces.
     */
    prepareProjectRefsRootConfigs(workspaceRoot, configPath, config) {
        const { srcFolder, testsFolder } = this.options;
        const optionsPath = configPath.parent().append('tsconfig.options.json');
        // Extract compiler options to a new config file
        fs_1.default.writeFileSync(optionsPath.path(), this.formatConfig({
            compilerOptions: Object.assign(Object.assign({}, config.compilerOptions), { 
                // Required for project references
                composite: true, declaration: true, declarationMap: true, 
                // Remove by marking as undefined
                outDir: undefined, outFile: undefined }),
        }));
        // Delete problematic root options
        delete config.compilerOptions;
        delete config.include;
        delete config.exclude;
        // Generate references and update paths
        config.extends = './tsconfig.options.json';
        config.files = [];
        config.references = [];
        this.tool.getWorkspacePackages({ root: workspaceRoot }).forEach(({ workspace }) => {
            const pkgPath = new core_1.Path(workspace.packagePath);
            const srcPath = pkgPath.append(srcFolder);
            const testsPath = pkgPath.append(testsFolder);
            // Reference a package *only* if it has a src folder
            if (srcFolder && srcPath.exists()) {
                config.references.push({
                    path: workspaceRoot.relativeTo(pkgPath).path(),
                });
                // Reference a separate tests folder if it exists
                if (testsFolder && testsPath.exists()) {
                    config.references.push({
                        path: workspaceRoot.relativeTo(testsPath).path(),
                    });
                }
            }
        });
        return optionsPath;
    }
}
exports.default = TypeScriptDriver;
