import Node from './Node';
import { PackageConfig, Tree } from './types';
export default class Graph<T extends PackageConfig = PackageConfig> {
    protected mapped: boolean;
    protected nodes: Map<string, Node>;
    protected packages: Map<string, T>;
    constructor(packages?: T[]);
    /**
     * Add a package by name with an associated `package.json` object.
     * Will map a dependency between the package and its dependees
     * found in `dependencies` and `peerDependencies`.
     */
    addPackage(pkg: T): this;
    /**
     * Add multiple packages.
     */
    addPackages(packages?: T[]): this;
    /**
     * Resolve the dependency graph and return a list of all
     * `package.json` objects in the order they are depended on.
     */
    resolveList(): T[];
    /**
     * Resolve the dependency graph and return a tree of nodes for all
     * `package.json` objects and their dependency mappings.
     */
    resolveTree(): Tree<T>;
    /**
     * Resolve the dependency graph and return a list of batched
     * `package.json` objects in the order they are depended on.
     */
    resolveBatchList(): T[][];
    /**
     * Add a node for the defined package name.
     */
    protected addNode(name: string): void;
    /**
     * Dig through all nodes and attempt to find a circular dependency cycle.
     */
    protected detectCycle(): void;
    /**
     * Return all nodes that can be considered "root",
     * as determined by having no requirements.
     */
    protected getRootNodes(): Node[];
    /**
     * Map dependencies between all currently registered packages.
     */
    protected mapDependencies(): void;
    /**
     * Map a dependency link for a dependent (child) depending on a requirement (parent).
     * Will link the parent and child accordingly, and will remove the child
     * from the root if it exists.
     */
    protected mapDependency(dependentName: string, requirementName: string): void;
    /**
     * Remove all current nodes in the graph and add new root nodes for each package.
     */
    protected resetNodes(): void;
    /**
     * Sort a set of nodes by most depended on, fall back to alpha sort as tie breaker
     */
    protected sortByDependedOn(nodes: Set<Node> | Node[]): Node[];
}
//# sourceMappingURL=Graph.d.ts.map