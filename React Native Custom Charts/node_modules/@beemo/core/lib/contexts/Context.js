"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@boost/core");
const camelCase_1 = __importDefault(require("lodash/camelCase"));
const trim_1 = __importDefault(require("lodash/trim"));
class Context extends core_1.Context {
    constructor(args) {
        super();
        this.argv = [];
        this.configPaths = [];
        // List of paths (with trailing glob star) for each defined workspace
        this.workspaces = [];
        this.args = args;
    }
    /**
     * Add a positional argument to the argv list.
     */
    addArg(arg) {
        this.args._.push(arg);
        this.argv.push(arg);
        return this;
    }
    /**
     * Add multiple positional arguments.
     */
    addArgs(args) {
        args.forEach((arg) => {
            this.addArg(arg);
        });
        return this;
    }
    /**
     * Add a config path for the defined driver.
     */
    addConfigPath(driverName, path) {
        this.configPaths.push({
            driver: driverName,
            path,
        });
        return this;
    }
    /**
     * Add an option argument to both the args object and argv list.
     */
    addOption(arg, defaultValue = true, useEquals = false) {
        const list = [];
        let option = arg;
        let value = defaultValue;
        if (option.includes('=')) {
            [option, value] = option.split('=');
            useEquals = true;
        }
        let name = trim_1.default(option, '-');
        if (name.startsWith('no-')) {
            name = name.slice(3);
            value = false;
        }
        this.args[name] = value;
        this.args[camelCase_1.default(name)] = value;
        if (typeof value === 'boolean' || !value) {
            list.push(option);
        }
        else if (useEquals) {
            list.push(`${option}=${value}`);
        }
        else {
            list.push(option, String(value));
        }
        this.argv.push(...list);
        return this;
    }
    /**
     * Add multiple boolean option arguments.
     */
    addOptions(args) {
        args.forEach((arg) => {
            this.addOption(arg);
        });
        return this;
    }
    /**
     * Find a configuration path by file name.
     */
    findConfigByName(name) {
        return this.configPaths.find((config) => String(config.path).endsWith(name) || config.driver === name);
    }
    /**
     * Return an argument or option value by name, or a fallback value if not found.
     */
    getArg(name, fallback) {
        return this.args[name] || fallback || null;
    }
}
exports.default = Context;
