import { Plugin, Task, TaskAction } from '@boost/core';
import { ConcurrentEvent } from '@boost/event';
import { Options } from 'yargs-parser';
import { Options as ExecaOptions, ExecaReturnValue } from 'execa';
import ScriptContext from './contexts/ScriptContext';
import { Argv, ExecuteType, ExecuteQueue } from './types';
export default abstract class Script<Args extends object = {}, Opts extends object = {}> extends Plugin<Opts> {
    tasks: Task<ScriptContext>[];
    onBeforeExecute: ConcurrentEvent<[ScriptContext<import("./contexts/ScriptContext").ScriptArgs>, Argv], string>;
    onAfterExecute: ConcurrentEvent<[ScriptContext<import("./contexts/ScriptContext").ScriptArgs>, unknown], string>;
    onFailedExecute: ConcurrentEvent<[ScriptContext<import("./contexts/ScriptContext").ScriptArgs>, Error], string>;
    /**
     * Define a configuration object to parse args with.
     */
    args(): Options;
    /**
     * Execute the script with the context and parsed args.
     */
    execute(context: ScriptContext, args: Args): Promise<unknown>;
    /**
     * Execute a command with the given arguments and pass the results through a promise.
     */
    executeCommand(command: string, args: string[], options?: ExecaOptions): Promise<ExecaReturnValue>;
    /**
     * Execute the enqueued tasks using the defined process.
     */
    executeTasks(type: ExecuteType): Promise<ExecuteQueue<ScriptContext>>;
    /**
     * Define an individual task that will be piped to an upstream routine.
     */
    task(title: string, action: TaskAction<ScriptContext>): Task<ScriptContext>;
}
//# sourceMappingURL=Script.d.ts.map