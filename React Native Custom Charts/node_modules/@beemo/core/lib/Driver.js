"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@boost/core");
const event_1 = require("@boost/event");
const mergeWith_1 = __importDefault(require("lodash/mergeWith"));
const execa_1 = __importDefault(require("execa"));
const optimal_1 = __importStar(require("optimal"));
const constants_1 = require("./constants");
class Driver extends core_1.Plugin {
    constructor() {
        super(...arguments);
        this.command = {};
        this.onLoadModuleConfig = new event_1.Event('load-module-config');
        this.onLoadPackageConfig = new event_1.Event('load-package-config');
        this.onMergeConfig = new event_1.Event('merge-config');
        this.onCreateConfigFile = new event_1.Event('create-config-file');
        this.onCopyConfigFile = new event_1.Event('copy-config-file');
        this.onReferenceConfigFile = new event_1.Event('reference-config-file');
        this.onDeleteConfigFile = new event_1.Event('delete-config-file');
        this.onBeforeExecute = new event_1.ConcurrentEvent('before-execute');
        this.onAfterExecute = new event_1.ConcurrentEvent('after-execute');
        this.onFailedExecute = new event_1.ConcurrentEvent('failed-execute');
    }
    blueprint(predicates) {
        // eslint-disable-next-line
        return {
            args: optimal_1.array(optimal_1.string()),
            dependencies: optimal_1.array(optimal_1.string()),
            env: optimal_1.object(optimal_1.string()),
            strategy: optimal_1.string(constants_1.STRATEGY_NATIVE).oneOf([
                constants_1.STRATEGY_NATIVE,
                constants_1.STRATEGY_CREATE,
                constants_1.STRATEGY_REFERENCE,
                constants_1.STRATEGY_COPY,
                constants_1.STRATEGY_NONE,
            ]),
        };
    }
    /**
     * Special case for merging arrays.
     */
    doMerge(prevValue, nextValue) {
        if (Array.isArray(prevValue) && Array.isArray(nextValue)) {
            return Array.from(new Set(prevValue.concat(nextValue)));
        }
        return undefined;
    }
    /**
     * Extract the error message when the driver fails to execute.
     */
    extractErrorMessage(error) {
        return error.message.split('\n', 1)[0] || '';
    }
    /**
     * Format the configuration file before it's written.
     */
    formatConfig(data) {
        const content = JSON.stringify(data, null, 2);
        if (this.metadata.configName.endsWith('.js')) {
            return `module.exports = ${content};`;
        }
        return content;
    }
    /**
     * Return a list of user defined arguments.
     */
    getArgs() {
        return Array.isArray(this.options.args) ? this.options.args : [];
    }
    /**
     * Return a list of dependent drivers.
     */
    getDependencies() {
        const dependencies = Array.isArray(this.options.dependencies) ? this.options.dependencies : [];
        return [
            // Always required; configured by the driver
            ...this.metadata.dependencies,
            // Custom; configured by the consumer
            ...dependencies,
        ];
    }
    /**
     * Return a list of supported CLI options.
     */
    getSupportedOptions() {
        return [];
    }
    /**
     * Extract the current version of the installed driver via its binary.
     */
    getVersion() {
        const { bin, versionOption } = this.metadata;
        const version = execa_1.default.sync(bin, [versionOption]).stdout.trim();
        const match = version.match(/(\d+)\.(\d+)\.(\d+)/u);
        return match ? match[0] : '0.0.0';
    }
    /**
     * Merge multiple configuration objects.
     */
    mergeConfig(prev, next) {
        return mergeWith_1.default(prev, next, this.doMerge);
    }
    /**
     * Handle command failures according to this driver.
     */
    processFailure(error) {
        const { stderr, stdout } = error;
        const out = (stderr || stdout).trim();
        // Integration debugging
        // this.tool.console.logError('STDERR', JSON.stringify(error));
        // Use console to by pass silent
        if (out) {
            this.tool.console.logError(out);
        }
    }
    /**
     * Handle successful commands according to this driver.
     */
    processSuccess(response) {
        const out = response.stdout.trim();
        // Integration debugging
        // this.tool.console.log('STDOUT', JSON.stringify(response));
        // Use console to by pass silent
        if (out) {
            this.tool.console.log(out);
        }
    }
    /**
     * Setup additional command options.
     */
    setCommandOptions(options) {
        const blueprint = {};
        Object.keys(options).forEach((key) => {
            blueprint[key] = optimal_1.shape({
                description: optimal_1.string().notEmpty().required(),
            });
        });
        this.command = optimal_1.default(options, blueprint, {
            name: this.constructor.name,
            unknown: true,
        });
        return this;
    }
    /**
     * Set metadata about the binary/executable in which this driver wraps.
     */
    setMetadata(metadata) {
        this.metadata = optimal_1.default(metadata, {
            bin: optimal_1.string()
                .match(/^[a-z]{1}[a-zA-Z0-9-]+$/u)
                .required(),
            configName: optimal_1.string().required(),
            configOption: optimal_1.string('--config'),
            configStrategy: optimal_1.string(constants_1.STRATEGY_CREATE).oneOf([
                constants_1.STRATEGY_CREATE,
                constants_1.STRATEGY_REFERENCE,
                constants_1.STRATEGY_COPY,
            ]),
            dependencies: optimal_1.array(optimal_1.string()),
            description: optimal_1.string(),
            filterOptions: optimal_1.bool(true),
            helpOption: optimal_1.string('--help'),
            title: optimal_1.string().required(),
            useConfigOption: optimal_1.bool(),
            versionOption: optimal_1.string('--version'),
            watchOptions: optimal_1.array(optimal_1.string()),
            workspaceStrategy: optimal_1.string(constants_1.STRATEGY_REFERENCE).oneOf([constants_1.STRATEGY_REFERENCE, constants_1.STRATEGY_COPY]),
        }, {
            name: this.constructor.name,
        });
        return this;
    }
}
exports.default = Driver;
