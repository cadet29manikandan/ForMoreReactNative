import { Argv as Yargv } from 'yargs';
import { Event } from '@boost/event';
import { Path } from '@boost/common';
import { Pipeline, Tool } from '@boost/core';
import Driver from './Driver';
import Context from './contexts/Context';
import ConfigContext from './contexts/ConfigContext';
import DriverContext from './contexts/DriverContext';
import ScriptContext from './contexts/ScriptContext';
import ScaffoldContext from './contexts/ScaffoldContext';
import { Argv, Execution, BeemoPluginRegistry, BeemoConfig, DriverOptions } from './types';
export declare function configBlueprint(): {
    configure: import("optimal").ShapePredicate<{
        cleanup: boolean;
        parallel: boolean;
    }>;
    execute: import("optimal").ShapePredicate<{
        concurrency: number;
        graph: boolean;
    }>;
    module: import("optimal").StringPredicate<string>;
};
export default class Beemo<T = any> extends Tool<BeemoPluginRegistry, BeemoConfig<T>> {
    moduleRoot?: Path;
    pipeline: Pipeline<any, Beemo<T>> | null;
    onResolveDependencies: Event<[ConfigContext<import("./contexts/ConfigContext").ConfigArgs>, Driver<object, DriverOptions>[]], string>;
    onRunConfig: Event<[ConfigContext<import("./contexts/ConfigContext").ConfigArgs>, string[]], string>;
    onRunDriver: Event<[DriverContext<import("./contexts/DriverContext").DriverArgs>, Driver<object, DriverOptions>], string>;
    onRunScript: Event<[ScriptContext<import("./contexts/ScriptContext").ScriptArgs>], string>;
    onScaffold: Event<[ScaffoldContext<import("./contexts/ScaffoldContext").ScaffoldArgs>, string, string, (string | undefined)?], string>;
    constructor(argv: Argv, binName?: string, testingOnly?: boolean);
    /**
     * Register global options within our CLI application.
     */
    bootstrapCLI(app: Yargv): void;
    /**
     * If the configure module has an index export that is a function,
     * execute it with the current tool instance.
     */
    bootstrapConfigModule(): this;
    /**
     * Create a configuration file for the specified driver names.
     */
    createConfigFiles(args: ConfigContext['args'], driverNames?: string[]): Promise<unknown>;
    /**
     * Validate the configuration module and return its absolute path.
     */
    getConfigModuleRoot(): Path;
    /**
     * Execute all routines for the chosen driver.
     */
    runDriver(args: DriverContext['args'], driverName: string, parallelArgv?: Argv[]): Promise<Execution[]>;
    /**
     * Run a script found within the configuration module.
     */
    runScript(args: ScriptContext['args'], scriptName: string): Promise<Execution>;
    /**
     * Run the scaffold process to generate templates.
     */
    scaffold(args: ScaffoldContext['args'], generator: string, action: string, name?: string): Promise<unknown>;
    /**
     * Setup and start a fresh pipeline.
     */
    startPipeline<C extends Context>(context: C): Pipeline<C, Beemo<T>>;
    /**
     * Prepare the context object by setting default values for specific properties.
     */
    protected prepareContext<T extends Context>(context: T): T;
    /**
     * Delete config files if a process fails.
     */
    private handleCleanupOnFailure;
}
//# sourceMappingURL=Beemo.d.ts.map