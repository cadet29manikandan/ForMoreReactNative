"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const camelCase_1 = __importDefault(require("lodash/camelCase"));
const upperFirst_1 = __importDefault(require("lodash/upperFirst"));
const event_1 = require("@boost/event");
const common_1 = require("@boost/common");
const core_1 = require("@boost/core");
const optimal_1 = require("optimal");
const CleanupConfigsRoutine_1 = __importDefault(require("./routines/CleanupConfigsRoutine"));
const ResolveConfigsRoutine_1 = __importDefault(require("./routines/ResolveConfigsRoutine"));
const RunDriverRoutine_1 = __importDefault(require("./routines/RunDriverRoutine"));
const RunScriptRoutine_1 = __importDefault(require("./routines/RunScriptRoutine"));
const ScaffoldRoutine_1 = __importDefault(require("./routines/ScaffoldRoutine"));
const Driver_1 = __importDefault(require("./Driver"));
const Script_1 = __importDefault(require("./Script"));
const ConfigContext_1 = __importDefault(require("./contexts/ConfigContext"));
const DriverContext_1 = __importDefault(require("./contexts/DriverContext"));
const ScriptContext_1 = __importDefault(require("./contexts/ScriptContext"));
const ScaffoldContext_1 = __importDefault(require("./contexts/ScaffoldContext"));
const constants_1 = require("./constants");
function configBlueprint() {
    return {
        configure: optimal_1.shape({
            cleanup: optimal_1.bool(false),
            parallel: optimal_1.bool(true),
        }),
        execute: optimal_1.shape({
            concurrency: optimal_1.number(),
            graph: optimal_1.bool(true),
        }),
        module: process.env.BEEMO_CONFIG_MODULE
            ? optimal_1.string(process.env.BEEMO_CONFIG_MODULE)
            : optimal_1.string().required(),
    };
}
exports.configBlueprint = configBlueprint;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class Beemo extends core_1.Tool {
    constructor(argv, binName, testingOnly = false) {
        super({
            appName: 'beemo',
            appPath: path_1.default.join(__dirname, '..'),
            configBlueprint: configBlueprint(),
            configName: binName || 'beemo',
            scoped: true,
        }, argv);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.pipeline = null;
        this.onResolveDependencies = new event_1.Event('resolve-dependencies');
        this.onRunConfig = new event_1.Event('run-config');
        this.onRunDriver = new event_1.Event('run-driver');
        this.onRunScript = new event_1.Event('run-script');
        this.onScaffold = new event_1.Event('scaffold');
        // eslint-disable-next-line global-require
        const { version } = require('../package.json');
        this.debug('Using beemo v%s', version);
        this.registerPlugin('driver', Driver_1.default);
        this.registerPlugin('script', Script_1.default);
        // Abort early for testing purposes
        if (testingOnly) {
            return;
        }
        this.initialize();
        // Set footer after messages have been loaded
        const footer = this.msg('app:poweredBy', { version });
        this.options.footer = `\n${this.isCI() ? '' : 'ðŸ¤–  '}${footer}`;
    }
    /**
     * Register global options within our CLI application.
     */
    bootstrapCLI(app) {
        core_1.CLI.registerGlobalOptions(app, this);
    }
    /**
     * If the configure module has an index export that is a function,
     * execute it with the current tool instance.
     */
    bootstrapConfigModule() {
        this.debug('Bootstrapping configuration module');
        const { module } = this.config;
        let bootstrap = null;
        try {
            if (module === '@local') {
                bootstrap = common_1.requireModule(this.getConfigModuleRoot().append('index.js'));
            }
            else {
                bootstrap = common_1.requireModule(module);
            }
        }
        catch (_a) {
            this.debug('No index.js file detected, aborting bootstrap');
            return this;
        }
        const isFunction = typeof bootstrap === 'function';
        this.debug.invariant(isFunction, 'Executing bootstrap function', 'Found', 'Not found');
        if (bootstrap && isFunction) {
            bootstrap(this);
        }
        return this;
    }
    /**
     * Create a configuration file for the specified driver names.
     */
    createConfigFiles(args, driverNames = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = this.prepareContext(new ConfigContext_1.default(args));
            // Create for all enabled drivers
            if (driverNames.length === 0) {
                this.getPlugins('driver').forEach((driver) => {
                    context.addDriverDependency(driver);
                    driverNames.push(driver.name);
                });
                this.debug('Running with all drivers');
                // Create for one or many driver
            }
            else {
                driverNames.forEach((driverName) => {
                    context.addDriverDependency(this.getPlugin('driver', driverName));
                });
                this.debug('Running with %s driver(s)', driverNames.join(', '));
            }
            this.onRunConfig.emit([context, driverNames]);
            return this.startPipeline(context)
                .pipe(new ResolveConfigsRoutine_1.default('config', this.msg('app:configGenerate')))
                .run();
        });
    }
    /**
     * Validate the configuration module and return its absolute path.
     */
    getConfigModuleRoot() {
        if (this.moduleRoot) {
            return this.moduleRoot;
        }
        const { configName } = this.options;
        const { module } = this.config;
        this.debug('Locating configuration module root');
        if (!module) {
            throw new Error(this.msg('errors:moduleConfigMissing', { configName }));
        }
        // Allow for local development
        if (module === '@local') {
            this.debug('Using %s configuration module', chalk_1.default.yellow('@local'));
            this.moduleRoot = new common_1.Path(process.cwd());
            return this.moduleRoot;
        }
        // Reference a node module
        let rootPath;
        try {
            rootPath = common_1.Path.resolve(require.resolve(module));
        }
        catch (_a) {
            throw new Error(this.msg('errors:moduleMissing', { configName, module }));
        }
        this.debug('Found configuration module root path: %s', chalk_1.default.cyan(rootPath));
        this.moduleRoot = rootPath;
        return rootPath;
    }
    /**
     * Execute all routines for the chosen driver.
     */
    runDriver(args, driverName, parallelArgv = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const driver = this.getPlugin('driver', driverName);
            const context = this.prepareContext(new DriverContext_1.default(args, driver, parallelArgv));
            const version = driver.getVersion();
            this.onRunDriver.emit([context, driver], driverName);
            this.debug('Running with %s v%s driver', driverName, version);
            const pipeline = this.startPipeline(context)
                .pipe(new ResolveConfigsRoutine_1.default('config', this.msg('app:configGenerate')))
                .pipe(new RunDriverRoutine_1.default('driver', this.msg('app:driverRun', {
                name: driver.metadata.title,
                version,
            })));
            // Only add cleanup routine if we need it
            if (this.config.configure.cleanup) {
                pipeline.pipe(new CleanupConfigsRoutine_1.default('cleanup', this.msg('app:cleanup')));
            }
            return pipeline.run(driverName);
        });
    }
    /**
     * Run a script found within the configuration module.
     */
    runScript(args, scriptName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!scriptName || !scriptName.match(constants_1.KEBAB_PATTERN)) {
                throw new Error(this.msg('errors:scriptNameInvalidFormat'));
            }
            const context = this.prepareContext(new ScriptContext_1.default(args, scriptName));
            this.onRunScript.emit([context], scriptName);
            this.debug('Running with %s script', context.scriptName);
            return this.startPipeline(context)
                .pipe(new RunScriptRoutine_1.default('script', 
            // Try and match the name of the class
            this.msg('app:scriptRun', { name: upperFirst_1.default(camelCase_1.default(context.scriptName)) })))
                .run();
        });
    }
    /**
     * Run the scaffold process to generate templates.
     */
    scaffold(args, generator, action, name = '') {
        return __awaiter(this, void 0, void 0, function* () {
            const context = this.prepareContext(new ScaffoldContext_1.default(args, generator, action, name));
            this.onScaffold.emit([context, generator, action, name]);
            this.debug('Running scaffold command');
            return this.startPipeline(context)
                .pipe(new ScaffoldRoutine_1.default('scaffold', this.msg('app:scaffoldGenerate')))
                .run();
        });
    }
    /**
     * Setup and start a fresh pipeline.
     */
    startPipeline(context) {
        // Make the tool available to all processes
        process.beemo = {
            context,
            // @ts-ignore
            tool: this,
        };
        // Delete config files on failure
        if (this.config.configure.cleanup) {
            this.onExit.listen((code) => this.handleCleanupOnFailure(code, context));
        }
        // Silence console reporter to inherit stdio
        if (context.args.stdio === 'inherit') {
            this.config.silent = true;
        }
        this.pipeline = new core_1.Pipeline(this, context);
        return this.pipeline;
    }
    /**
     * Prepare the context object by setting default values for specific properties.
     */
    prepareContext(context) {
        context.argv = this.argv;
        context.cwd = common_1.Path.resolve(this.options.root);
        context.moduleRoot = this.getConfigModuleRoot();
        context.workspaceRoot = common_1.Path.resolve(this.options.workspaceRoot || this.options.root);
        context.workspaces = this.getWorkspacePaths({ root: context.workspaceRoot });
        return context;
    }
    /**
     * Delete config files if a process fails.
     */
    handleCleanupOnFailure(code, context) {
        if (code === 0) {
            return;
        }
        // Must not be async!
        if (Array.isArray(context.configPaths)) {
            context.configPaths.forEach((config) => {
                fs_extra_1.default.removeSync(config.path.path());
            });
        }
    }
}
exports.default = Beemo;
