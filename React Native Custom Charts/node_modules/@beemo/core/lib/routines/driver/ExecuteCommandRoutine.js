"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@boost/common");
const core_1 = require("@boost/core");
const chalk_1 = __importDefault(require("chalk"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const is_glob_1 = __importDefault(require("is-glob"));
const merge_1 = __importDefault(require("lodash/merge"));
const yargs_parser_1 = __importDefault(require("yargs-parser"));
const BatchStream_1 = __importDefault(require("../../streams/BatchStream"));
const formatExecReturn_1 = __importDefault(require("../../utils/formatExecReturn"));
const filterArgs_1 = __importDefault(require("../../utils/filterArgs"));
const constants_1 = require("../../constants");
const OPTION_PATTERN = /-?-[a-z0-9-]+(,|\s)/giu;
class ExecuteCommandRoutine extends core_1.Routine {
    constructor() {
        super(...arguments);
        /**
         * Capture live output via `--stdio=pipe` or `--watch`. Buffer the output incase ctrl+c is entered.
         */
        this.captureOutput = (stream) => {
            const { args, primaryDriver } = this.context;
            const { watchOptions } = primaryDriver.metadata;
            const isWatching = watchOptions.some((option) => {
                // Option
                if (option.startsWith('-')) {
                    return !!args[option.replace(/^-{1,2}/u, '')];
                }
                // Argument
                return args._.includes(option);
            });
            if (isWatching) {
                const wait = 1000;
                const handler = (chunk) => {
                    process.stdout.write(String(chunk));
                };
                stream.stdout.pipe(new BatchStream_1.default({ wait })).on('data', handler);
                stream.stderr.pipe(new BatchStream_1.default({ wait })).on('data', handler);
                return 'watch';
            }
            let buffer = '';
            // When cmd/ctrl + c is pressed, write out the current buffer
            if (args.stdio === 'buffer') {
                this.tool.console.onError.listen((error) => {
                    if ((error instanceof core_1.SignalError || error.name === 'SignalError') &&
                        // @ts-ignore Temporary fix
                        (error.signal === 'SIGINT' || error.signal === 'SIGTERM')) {
                        process.stdout.write(chalk_1.default.gray(this.tool.msg('app:signalBufferMessage')));
                        process.stdout.write(`\n\n${buffer}`);
                    }
                });
            }
            // When streaming or inheriting, output immediately,
            // otherwise buffer for the reporter.
            const handler = (chunk) => {
                if (args.stdio === 'stream' || args.stdio === 'inherit') {
                    process.stdout.write(String(chunk));
                }
                else {
                    buffer += String(chunk);
                }
            };
            stream.stdout.on('data', handler);
            stream.stderr.on('data', handler);
            return args.stdio || 'buffer';
        };
    }
    blueprint({ array, bool, string }) {
        return {
            additionalArgv: array(string()),
            argv: array(string()),
            forceConfigOption: bool(),
            packageRoot: string(),
        };
    }
    bootstrap() {
        const { tool } = this;
        const { forceConfigOption, packageRoot } = this.options;
        const { metadata } = this.context.primaryDriver;
        this.task(tool.msg('app:driverExecuteGatherArgs'), this.gatherArgs);
        this.task(tool.msg('app:driverExecuteExpandGlob'), this.expandGlobPatterns);
        this.task(tool.msg('app:driverExecuteFilterOptions'), this.filterUnknownOptions).skip(!metadata.filterOptions);
        if (packageRoot && metadata.workspaceStrategy === constants_1.STRATEGY_COPY) {
            this.task(tool.msg('app:driverExecuteCopyWorkspaceConfig'), this.copyConfigToWorkspacePackage);
        }
        else {
            this.task(tool.msg('app:driverExecuteIncludeConfigOption'), this.includeConfigOption).skip(!metadata.useConfigOption && !forceConfigOption);
        }
        this.task(tool.msg('app:driverExecute'), this.runCommandWithArgs);
    }
    /**
     * When workspaces are enabled, some drivers require the config to be within each workspace,
     * instead of being referenced from the root, so we need to copy it.
     */
    copyConfigToWorkspacePackage(context, argv) {
        const { packageRoot } = this.options;
        this.debug('Copying config files to workspace');
        context.configPaths.forEach((config) => {
            fs_extra_1.default.copyFileSync(config.path.path(), new common_1.Path(packageRoot, config.path.name()).path());
        });
        return argv;
    }
    /**
     * Expand arguments that look like globs.
     */
    expandGlobPatterns(context, argv) {
        const nextArgv = [];
        this.debug('Expanding glob patterns');
        argv.forEach((arg) => {
            if (arg.charAt(0) !== '-' && is_glob_1.default(arg)) {
                const paths = fast_glob_1.default
                    .sync(arg, {
                    cwd: String(context.cwd),
                    onlyDirectories: false,
                    onlyFiles: false,
                })
                    .map((path) => new common_1.Path(path).path());
                this.debug('  %s %s %s', arg, chalk_1.default.gray('->'), paths.length > 0 ? paths.join(', ') : chalk_1.default.gray(this.tool.msg('app:noMatch')));
                nextArgv.push(...paths);
            }
            else {
                nextArgv.push(arg);
            }
        });
        return nextArgv;
    }
    /**
     * Extract native supported options and flags from driver help output.
     */
    extractNativeOptions() {
        return __awaiter(this, void 0, void 0, function* () {
            const driver = this.context.primaryDriver;
            const { env } = driver.options;
            const options = driver.getSupportedOptions();
            if (options.length > 0) {
                this.debug('Using supported options from driver');
                const nativeOptions = {};
                options.forEach((option) => {
                    nativeOptions[option] = true;
                });
                return Promise.resolve(nativeOptions);
            }
            this.debug('Extracting native options from help output');
            const { stdout } = yield this.executeCommand(driver.metadata.bin, driver.metadata.helpOption.split(' '), {
                env,
            });
            const nativeOptions = {};
            const matches = stdout.match(OPTION_PATTERN) || [];
            matches.forEach((option) => {
                // Trim trailing comma or space
                nativeOptions[option.slice(0, -1)] = true;
            });
            return nativeOptions;
        });
    }
    /**
     * Filter unknown and or unsupported CLI options from the arguments passed to the CLI.
     * Utilize the driver's help option/command to determine accurate options.
     */
    filterUnknownOptions(context, argv) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug('Filtering unknown command line options');
            const nativeOptions = yield this.extractNativeOptions();
            const { filteredArgv, unknownArgv } = filterArgs_1.default(argv, {
                allow: nativeOptions,
            });
            if (unknownArgv.length > 0) {
                this.debug('Filtered args: %s', chalk_1.default.gray(unknownArgv.join(', ')));
            }
            return filteredArgv;
        });
    }
    /**
     * Gather arguments from all sources to pass to the driver.
     */
    gatherArgs(context) {
        this.debug('Gathering arguments to pass to driver');
        const argv = [
            // Passed by the driver
            ...this.getDriverArgs(),
            // Passed on the command line
            ...this.getCommandLineArgs(),
            // Passed with parallel "//" operator
            ...this.getAdditionalArgs(),
        ];
        // Since we combine multiple args, we need to rebuild this.
        // And we need to set this before we filter them.
        // And we need to be sure not to remove existing args.
        context.args = merge_1.default({}, yargs_parser_1.default(argv), context.args);
        return argv;
    }
    /**
     * Run some validation on additional/parallel args.
     */
    getAdditionalArgs() {
        const argv = this.options.additionalArgv;
        this.debug.invariant(argv.length > 0, 'From parallel operator', argv.join(' '), 'No arguments');
        return argv;
    }
    /**
     * Return args from the command line.
     */
    getCommandLineArgs() {
        const { argv } = this.options;
        this.debug.invariant(argv.length > 0, 'From the command line', argv.join(' '), 'No arguments');
        return argv;
    }
    /**
     * Return args from the primary driver.
     */
    getDriverArgs() {
        const argv = this.context.primaryDriver.getArgs();
        this.debug.invariant(argv.length > 0, 'From driver "args" option', argv.join(' '), 'No arguments');
        return argv;
    }
    /**
     * Include --config option if driver requires it (instead of auto-lookup resolution).
     */
    includeConfigOption(context, prevArgv) {
        const { primaryDriver } = context;
        const configPath = context.findConfigByName(primaryDriver.metadata.configName);
        const argv = [...prevArgv];
        if (configPath && primaryDriver.metadata.configOption) {
            argv.push(primaryDriver.metadata.configOption, configPath.path.path());
        }
        this.debug('Including config option to args');
        return argv;
    }
    /**
     * Execute the driver's command with the filtered arguments and handle the
     * success and failures with the driver itself.
     */
    runCommandWithArgs(context, argv, task) {
        return __awaiter(this, void 0, void 0, function* () {
            const driver = context.primaryDriver;
            const cwd = String(this.options.packageRoot || context.cwd);
            let result = null;
            this.debug('Executing command "%s %s" in %s', chalk_1.default.magenta(driver.metadata.bin), argv.join(' '), chalk_1.default.cyan(cwd));
            yield driver.onBeforeExecute.emit([context, argv]);
            try {
                result = yield this.executeCommand(driver.metadata.bin, argv, {
                    cwd,
                    env: driver.options.env,
                    task,
                    wrap: this.captureOutput,
                });
                this.debug('  Success: %o', formatExecReturn_1.default(result));
                driver.processSuccess(result);
                yield driver.onAfterExecute.emit([context, result]);
            }
            catch (error) {
                result = error;
                this.debug('  Failure: %o', formatExecReturn_1.default(result));
                this.debug('  Error message: %s', chalk_1.default.gray(result.message));
                if (result.name !== 'MaxBufferError') {
                    driver.processFailure(result);
                }
                yield driver.onFailedExecute.emit([context, result]);
                // Throw a new formatted error with the old stack trace
                let newError;
                // https://nodejs.org/api/child_process.html#child_process_event_exit
                if (result.exitCode === null && result.signal === 'SIGKILL') {
                    newError = new core_1.ExitError('Out of memory!', 1);
                }
                else {
                    newError = new core_1.ExitError((driver.extractErrorMessage(result) || '').trim(), error.exitCode);
                }
                if (error.stack) {
                    newError.stack = error.stack;
                }
                throw newError;
            }
            return result;
        });
    }
}
exports.default = ExecuteCommandRoutine;
