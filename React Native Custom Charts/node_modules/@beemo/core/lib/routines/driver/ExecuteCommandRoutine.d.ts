import { Routine, Task, Predicates } from '@boost/core';
import execa from 'execa';
import Beemo from '../../Beemo';
import DriverContext from '../../contexts/DriverContext';
import { OptionMap } from '../../utils/filterArgs';
import { Argv, Execution } from '../../types';
export interface ExecuteCommandOptions {
    additionalArgv?: Argv;
    argv?: Argv;
    forceConfigOption?: boolean;
    packageRoot?: string;
}
export default class ExecuteCommandRoutine extends Routine<DriverContext, Beemo, ExecuteCommandOptions> {
    blueprint({ array, bool, string }: Predicates): {
        additionalArgv: import("optimal").ArrayPredicate<string>;
        argv: import("optimal").ArrayPredicate<string>;
        forceConfigOption: import("optimal").BooleanPredicate<boolean>;
        packageRoot: import("optimal").StringPredicate<string>;
    };
    bootstrap(): void;
    /**
     * Capture live output via `--stdio=pipe` or `--watch`. Buffer the output incase ctrl+c is entered.
     */
    captureOutput: (stream: execa.ExecaChildProcess<string>) => "inherit" | "watch" | "buffer" | "stream";
    /**
     * When workspaces are enabled, some drivers require the config to be within each workspace,
     * instead of being referenced from the root, so we need to copy it.
     */
    copyConfigToWorkspacePackage(context: DriverContext, argv: Argv): Argv;
    /**
     * Expand arguments that look like globs.
     */
    expandGlobPatterns(context: DriverContext, argv: Argv): Argv;
    /**
     * Extract native supported options and flags from driver help output.
     */
    extractNativeOptions(): Promise<OptionMap>;
    /**
     * Filter unknown and or unsupported CLI options from the arguments passed to the CLI.
     * Utilize the driver's help option/command to determine accurate options.
     */
    filterUnknownOptions(context: DriverContext, argv: Argv): Promise<Argv>;
    /**
     * Gather arguments from all sources to pass to the driver.
     */
    gatherArgs(context: DriverContext): Argv;
    /**
     * Run some validation on additional/parallel args.
     */
    getAdditionalArgs(): Argv;
    /**
     * Return args from the command line.
     */
    getCommandLineArgs(): Argv;
    /**
     * Return args from the primary driver.
     */
    getDriverArgs(): Argv;
    /**
     * Include --config option if driver requires it (instead of auto-lookup resolution).
     */
    includeConfigOption(context: DriverContext, prevArgv: Argv): Argv;
    /**
     * Execute the driver's command with the filtered arguments and handle the
     * success and failures with the driver itself.
     */
    runCommandWithArgs(context: DriverContext, argv: Argv, task: Task<DriverContext>): Promise<Execution>;
}
//# sourceMappingURL=ExecuteCommandRoutine.d.ts.map