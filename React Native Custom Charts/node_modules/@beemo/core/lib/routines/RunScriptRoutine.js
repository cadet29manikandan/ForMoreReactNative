"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const camelCase_1 = __importDefault(require("lodash/camelCase"));
const upperFirst_1 = __importDefault(require("lodash/upperFirst"));
const common_1 = require("@boost/common");
const formatModuleName_1 = __importDefault(require("@boost/core/lib/helpers/formatModuleName"));
const filterArgs_1 = __importDefault(require("../utils/filterArgs"));
const constants_1 = require("../constants");
const ExecuteScriptRoutine_1 = __importDefault(require("./script/ExecuteScriptRoutine"));
const RunInWorkspacesRoutine_1 = __importDefault(require("./RunInWorkspacesRoutine"));
class RunScriptRoutine extends RunInWorkspacesRoutine_1.default {
    constructor() {
        super(...arguments);
        this.errors = [];
    }
    bootstrap() {
        super.bootstrap();
        this.task(this.tool.msg('app:scriptLoad'), this.loadScriptFromTool);
        this.task(this.tool.msg('app:scriptLoadModule'), this.loadScriptFromModule);
        this.task(this.tool.msg('app:scriptLoadPost'), this.postLoad);
    }
    pipeRoutine(packageName, packageRoot) {
        const { argv, cwd, scriptName } = this.context;
        const { filteredArgv } = filterArgs_1.default(argv, {
            block: constants_1.EXECUTE_OPTIONS,
        });
        const command = filteredArgv.join(' ');
        if (packageName) {
            this.pipe(new ExecuteScriptRoutine_1.default(packageName, command, {
                packageRoot,
            }));
        }
        else {
            this.pipe(new ExecuteScriptRoutine_1.default(scriptName, command, {
                packageRoot: cwd.path(),
            }));
        }
    }
    /**
     * If the script has been loaded into the tool, return that directly.
     * Scripts can be preloaded from a configuration file or the command line.
     */
    loadScriptFromTool(context) {
        this.debug('Attempting to load script from tool');
        try {
            const script = this.tool.getPlugin('script', context.scriptName);
            context.setScript(script, script.moduleName);
            return script;
        }
        catch (error) {
            error.message = this.tool.msg('app:fromTool', { message: error.message });
            this.errors.push(error);
            return null;
        }
    }
    /**
     * Attempt to load a script from the configuration module's `scripts/` folder,
     * or a standard Node modules folder.
     */
    loadScriptFromModule(context, script) {
        if (script) {
            return script;
        }
        this.debug('Attempting to load script from configuration module or node module');
        const moduleName = this.tool.config.module;
        const fileName = upperFirst_1.default(camelCase_1.default(context.scriptName));
        const resolver = new common_1.PathResolver();
        if (moduleName === '@local') {
            resolver
                .lookupFilePath(`lib/scripts/${fileName}.js`, context.moduleRoot)
                .lookupFilePath(`scripts/${fileName}.js`, context.moduleRoot);
        }
        else {
            resolver
                .lookupNodeModule(`${moduleName}/lib/scripts/${fileName}`)
                .lookupNodeModule(`${moduleName}/scripts/${fileName}`)
                .lookupNodeModule(formatModuleName_1.default('beemo', 'script', context.scriptName, true))
                .lookupNodeModule(formatModuleName_1.default('beemo', 'script', context.scriptName));
        }
        try {
            const { originalPath, resolvedPath } = resolver.resolve();
            script = this.tool.getRegisteredPlugin('script').loader.importModule(resolvedPath);
            script.name = context.scriptName;
            script.moduleName = originalPath.path();
            context.setScript(script, resolvedPath.path());
        }
        catch (error) {
            error.message = this.tool.msg('app:fromModule', { message: error.message });
            this.errors.push(error);
        }
        return script || null;
    }
    /**
     * If all of the loading patterns have failed, thrown an error,
     * otherwise add the script and continue.
     */
    postLoad(context, script) {
        if (!script) {
            const messages = this.errors.map((error) => `  - ${error.message}`).join('\n');
            throw new Error(`Failed to load script from multiple sources:\n${messages}`);
        }
        this.tool.addPlugin('script', script);
        return script;
    }
}
exports.default = RunScriptRoutine;
