"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@boost/core");
const dependency_graph_1 = __importDefault(require("@beemo/dependency-graph"));
const chalk_1 = __importDefault(require("chalk"));
// eslint-disable-next-line
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const isPatternMatch_1 = __importDefault(require("../utils/isPatternMatch"));
const MAX_ERROR_LINES = 5;
class RunInWorkspacesRoutine extends core_1.Routine {
    constructor() {
        super(...arguments);
        this.workspacePackages = [];
    }
    bootstrap() {
        const { args, workspaceRoot, workspaces } = this.context;
        if (args.workspaces) {
            if (!workspaces || workspaces.length === 0) {
                throw new Error(this.tool.msg('errors:workspacesNotEnabled', { arg: args.workspaces }));
            }
            this.workspacePackages = this.tool.getWorkspacePackages({
                root: workspaceRoot,
            });
            this.getFilteredWorkspacePackages().forEach((pkg) => {
                this.pipeRoutine(pkg.workspace.packageName, pkg.workspace.packagePath);
            });
        }
        else {
            this.pipeRoutine();
        }
    }
    execute(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const value = yield this.serializeTasks();
            const batches = this.orderByWorkspacePriorityGraph();
            const allErrors = [];
            const allResults = [];
            const concurrency = context.args.concurrency || this.tool.config.execute.concurrency;
            // eslint-disable-next-line no-restricted-syntax
            for (const batch of batches) {
                // eslint-disable-next-line no-await-in-loop
                const { errors, results } = yield this.poolRoutines(value, concurrency ? { concurrency } : {}, batch);
                allResults.push(...results);
                if (errors.length > 0) {
                    allErrors.push(...errors);
                }
            }
            if (allErrors.length > 0) {
                this.formatAndThrowErrors(allErrors);
            }
            // Not running in workspaces, so return value directly
            return context.args.workspaces ? allResults : allResults[0];
        });
    }
    /**
     * When a list of errors are available, concatenate them and throw a new error.
     */
    formatAndThrowErrors(errors) {
        let message = this.tool.msg('errors:executeFailed');
        errors.forEach((error) => {
            let content = strip_ansi_1.default(error.stderr || error.stdout || '')
                .trim()
                .split('\n');
            if (content.length >= MAX_ERROR_LINES) {
                const count = content.length - MAX_ERROR_LINES;
                content = content.slice(0, MAX_ERROR_LINES);
                if (count > 0) {
                    content.push(this.tool.msg('errors:executeFailedMoreLines', { count }));
                }
            }
            message += '\n\n';
            message += chalk_1.default.reset.yellow(error.message);
            if (content.length > 0) {
                message += '\n';
                message += chalk_1.default.reset.gray(content.join('\n'));
            }
        });
        message += '\n';
        const error = new Error(message);
        // Inherit stack for easier debugging.
        if (errors.length === 1) {
            error.stack = String(errors[0].stack).split('\n').slice(1).join('\n');
        }
        throw error;
    }
    /**
     * Return a list of workspaces optionally filtered.
     */
    getFilteredWorkspacePackages() {
        return this.workspacePackages.filter((pkg) => isPatternMatch_1.default(pkg.name, this.context.args.workspaces));
    }
    /**
     * Group routines in order of which they are dependend on.
     */
    orderByWorkspacePriorityGraph() {
        const enabled = this.context.args.graph || this.tool.config.execute.graph;
        if (!enabled || !this.context.args.workspaces) {
            return [this.routines];
        }
        const batchList = new dependency_graph_1.default(this.workspacePackages).resolveBatchList();
        const batches = [];
        batchList.forEach((batch) => {
            const routines = batch
                .map((pkg) => this.routines.find((route) => route.key === pkg.workspace.packageName))
                .filter(Boolean);
            if (routines.length > 0) {
                batches.push(routines);
            }
        });
        return batches;
    }
}
exports.default = RunInWorkspacesRoutine;
