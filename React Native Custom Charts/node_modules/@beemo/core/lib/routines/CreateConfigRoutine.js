"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const camelCase_1 = __importDefault(require("lodash/camelCase"));
const common_1 = require("@boost/common");
const core_1 = require("@boost/core");
const Driver_1 = __importDefault(require("../Driver"));
const constants_1 = require("../constants");
class CreateConfigRoutine extends core_1.Routine {
    blueprint({ instance }) {
        // eslint-disable-next-line
        return {
            driver: instance(Driver_1.default, true)
                .required()
                .notNullable(),
        };
    }
    bootstrap() {
        const { tool } = this;
        const { metadata, options } = this.options.driver;
        const name = metadata.title;
        const strategy = options.strategy === constants_1.STRATEGY_NATIVE ? metadata.configStrategy : options.strategy;
        this.task(tool.msg('app:configSetEnvVars', { name }), this.setEnvVars);
        switch (strategy) {
            case constants_1.STRATEGY_REFERENCE:
                this.task(tool.msg('app:configReference', { name }), this.referenceConfigFile);
                break;
            case constants_1.STRATEGY_COPY:
                this.task(tool.msg('app:configCopy', { name }), this.copyConfigFile);
                break;
            case constants_1.STRATEGY_CREATE:
                this.task(tool.msg('app:configCreateLoadFile', { name }), this.loadConfigFromSources);
                this.task(tool.msg('app:configCreateLoadPackage', { name }), this.extractConfigFromPackage);
                this.task(tool.msg('app:configCreateMerge', { name }), this.mergeConfigs);
                this.task(tool.msg('app:configCreate', { name }), this.createConfigFile);
                break;
            default:
                this.skip(true);
                break;
        }
    }
    execute() {
        return this.serializeTasks([]);
    }
    /**
     * Copy configuration file from module.
     */
    copyConfigFile(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const { driver } = this.options;
            const { metadata, name } = driver;
            const sourcePath = this.getConfigPath();
            const configPath = context.cwd.append(metadata.configName);
            if (!sourcePath) {
                throw new Error(this.tool.msg('errors:configCopySourceMissing'));
            }
            const config = this.loadConfig(sourcePath);
            this.debug('Copying config file to %s', chalk_1.default.cyan(configPath));
            driver.config = config;
            driver.onCopyConfigFile.emit([context, configPath, config]);
            context.addConfigPath(name, configPath);
            return fs_extra_1.default
                .copy(sourcePath.path(), configPath.path(), {
                overwrite: true,
            })
                .then(() => configPath);
        });
    }
    /**
     * Create a temporary configuration file or pass as an option.
     */
    createConfigFile(context, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const { driver } = this.options;
            const { metadata, name } = driver;
            const configPath = context.cwd.append(metadata.configName);
            this.debug('Creating config file %s', chalk_1.default.cyan(configPath));
            driver.config = config;
            driver.onCreateConfigFile.emit([context, configPath, config]);
            context.addConfigPath(name, configPath);
            return fs_extra_1.default
                .writeFile(configPath.path(), this.options.driver.formatConfig(config))
                .then(() => configPath);
        });
    }
    /**
     * Extract configuration from "beemo.<driver>" within the local project's package.json.
     */
    extractConfigFromPackage(context, prevConfigs) {
        const { driver } = this.options;
        const { name } = driver;
        const { config } = this.tool;
        const configs = [...prevConfigs];
        const configName = this.getConfigName(name);
        this.debug.invariant(!!config[configName], `Extracting ${chalk_1.default.green(name)} config from package.json`, 'Exists, extracting', 'Does not exist, skipping');
        if (config[configName]) {
            const pkgConfig = config[configName];
            configs.push(pkgConfig);
            driver.onLoadPackageConfig.emit([context, pkgConfig]);
        }
        return Promise.resolve(configs);
    }
    /**
     * Return file name camel cased.
     */
    getConfigName(name) {
        return camelCase_1.default(name);
    }
    /**
     * Return absolute file path for config file within configuration module,
     * or an empty string if it does not exist.
     */
    getConfigPath(forceLocal = false) {
        const { cwd, workspaceRoot } = this.context;
        const moduleName = this.tool.config.module;
        const { name } = this.options.driver;
        const configName = this.getConfigName(name);
        const isLocal = moduleName === '@local' || forceLocal;
        const resolver = new common_1.PathResolver();
        // Allow for local development
        if (isLocal) {
            resolver
                .lookupFilePath(`lib/configs/${configName}.js`, workspaceRoot || cwd)
                .lookupFilePath(`configs/${configName}.js`, workspaceRoot || cwd);
        }
        else {
            resolver
                .lookupNodeModule(`${moduleName}/lib/configs/${configName}`)
                .lookupNodeModule(`${moduleName}/configs/${configName}`);
        }
        let configPath = null;
        try {
            configPath = resolver.resolvePath();
        }
        catch (_a) {
            // Ignore
        }
        this.debug.invariant(!!configPath, isLocal
            ? `Loading ${chalk_1.default.green(name)} config from local consumer`
            : `Loading ${chalk_1.default.green(name)} config from configuration module ${chalk_1.default.yellow(moduleName)}`, 'Exists, loading', 'Does not exist, skipping');
        if (configPath) {
            this.debug('Found at %s', chalk_1.default.cyan(configPath));
        }
        return configPath;
    }
    /**
     * Merge multiple configuration sources using the current driver.
     */
    mergeConfigs(context, configs) {
        const { driver } = this.options;
        const { name } = driver;
        this.debug('Merging %s config from %d sources', chalk_1.default.green(name), configs.length);
        const config = configs.reduce((masterConfig, cfg) => this.options.driver.mergeConfig(masterConfig, cfg), {});
        driver.onMergeConfig.emit([context, config]);
        return Promise.resolve(config);
    }
    /**
     * Load a config file with passing the args and tool to the file.
     */
    loadConfig(filePath) {
        const config = common_1.requireModule(filePath);
        if (typeof config === 'function') {
            throw new TypeError(this.tool.msg('errors:configNoFunction', { name: filePath.name() }));
        }
        this.options.driver.onLoadModuleConfig.emit([this.context, filePath, config]);
        return config;
    }
    /**
     * Load config from the provider configuration module
     * and from the local configs/ folder in the consumer.
     */
    loadConfigFromSources(context, prevConfigs) {
        const sourcePath = this.getConfigPath();
        const localPath = this.getConfigPath(true);
        const configs = [...prevConfigs];
        if (sourcePath) {
            configs.push(this.loadConfig(sourcePath));
        }
        // Local files should override anything defined in the configuration module above
        // Also don't double load files, so check against @local to avoid
        if (localPath && sourcePath && localPath.path() !== sourcePath.path()) {
            configs.push(this.loadConfig(localPath));
        }
        return Promise.resolve(configs);
    }
    /**
     * Reference configuration file from module using a require statement.
     */
    referenceConfigFile(context) {
        const { driver } = this.options;
        const { metadata, name } = driver;
        const sourcePath = this.getConfigPath();
        const configPath = context.cwd.append(metadata.configName);
        if (!sourcePath) {
            throw new Error(this.tool.msg('errors:configReferenceSourceMissing'));
        }
        const config = this.loadConfig(sourcePath);
        this.debug('Referencing config file to %s', chalk_1.default.cyan(configPath));
        driver.config = config;
        driver.onReferenceConfigFile.emit([context, configPath, config]);
        context.addConfigPath(name, configPath);
        const requirePath = context.cwd.relativeTo(sourcePath);
        return fs_extra_1.default
            .writeFile(configPath.path(), `module.exports = require('./${requirePath}');`)
            .then(() => configPath);
    }
    /**
     * Set environment variables defined by the driver.
     */
    setEnvVars(context, configs) {
        const { env } = this.options.driver.options;
        // TODO: This may cause collisions, isolate in a child process?
        Object.keys(env).forEach((key) => {
            process.env[key] = env[key];
        });
        return Promise.resolve(configs);
    }
}
exports.default = CreateConfigRoutine;
