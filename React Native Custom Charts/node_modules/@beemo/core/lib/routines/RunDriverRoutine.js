"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ExecuteCommandRoutine_1 = __importDefault(require("./driver/ExecuteCommandRoutine"));
const RunInWorkspacesRoutine_1 = __importDefault(require("./RunInWorkspacesRoutine"));
const filterArgs_1 = __importDefault(require("../utils/filterArgs"));
const constants_1 = require("../constants");
class ExecuteDriverRoutine extends RunInWorkspacesRoutine_1.default {
    pipeRoutine(packageName, packageRoot) {
        if (packageName) {
            this.pipeParallelBuilds(packageName, {
                forceConfigOption: true,
                packageRoot,
            });
        }
        else {
            this.pipeParallelBuilds(this.context.primaryDriver.name);
        }
    }
    /**
     * When a parallel pipe "//" is defined, we need to create an additional routine
     * for each instance.
     */
    pipeParallelBuilds(key, options = {}) {
        const { argv, parallelArgv, primaryDriver } = this.context;
        const { filteredArgv } = filterArgs_1.default(argv, {
            block: constants_1.EXECUTE_OPTIONS,
        });
        const command = `${primaryDriver.metadata.bin} ${filteredArgv.join(' ')}`.trim();
        this.pipe(new ExecuteCommandRoutine_1.default(key, command, Object.assign(Object.assign({}, options), { argv: filteredArgv })));
        parallelArgv.forEach((pargv) => {
            this.pipe(new ExecuteCommandRoutine_1.default(key, `${command} ${pargv.join(' ')}`.trim(), Object.assign(Object.assign({}, options), { additionalArgv: pargv, argv: filteredArgv })));
        });
    }
}
exports.default = ExecuteDriverRoutine;
